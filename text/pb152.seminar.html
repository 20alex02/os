<!DOCTYPE html><html lang="cs"><head><meta charset="UTF-8"><!-- ‹really› --><title>@subject@</title><style>body
{
    margin-left: 13.6em;
    padding: .3em;
    max-width: 40em; 
    text-align: justify;
    hyphens: auto;
    font-family: "Aleo Light", serif;
}

#toc
{
    display: block;
    margin-left: -13.3em;
    width: 12em;
    padding: .3em;
    height: 100%;
    position: fixed;
    font-family: "Lato Light", sans-serif;
}

code, tt { font-family: "Iosevka Slab Extralight", monospace; font-size: 90%; color: darkgreen; }
em { font-style: normal; color: darkred; }

a:link, a:visited { color: navy; text-decoration: none; }

#toc .h2, #toc .h3 { display: none; }
#toc .expanded .h2 { display: block; }
#toc li {
    width: 12em;
    display: block; 
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}

#toc ol { padding-inline-start: 1em; display: block; }
div ol, div ul { margin-block-start: .5em; margin-block-end: 1.4ex; }
li > ol { padding-inline-start: 1.2em; list-style-type: lower-alpha; }

.footnote { display: flex; flex-direction: row; font-size: smaller; }
.footnote > a { padding-right: .5em; }
.footnotes { border-top: 1px solid black; padding-top: .5ex; display: flex; flex-direction: column; }

table { margin: auto; margin-top: 6pt; margin-bottom: 6pt; border-collapse: collapse; }
td { padding: 2pt; }
.center { text-align: center; margin-top: 6pt; margin-bottom: 6pt; }
.right  { text-align: right; }
h1, h2, h3 { font-family: "Aleo Regular"; font-weight: normal; }

h3 { display: inline; font-size: 100%; font-weight: bold; }
h3 + .par { display: inline; }
a + .par { display: inline; }
a + .par + .par { margin-top: .5em }
h3:before { content: ' '; display: block; margin-top: .5em; }

div { padding-bottom: .5em; }
pre { padding-top: 0; padding-bottom: .5em; margin-top: .5em; margin-bottom: .5em; }
img { display: block; max-width: 97%; margin: 1.5ex auto 1.5ex auto; }

.hrule { border-top: 1px solid black; }
.vrule { border-left: 1px solid black; }
.even { table-layout: fixed; width: 90%; }

/* Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org> */

.hljs {
  display: block;
  overflow-x: auto;
}

/* Base color: saturation 0; */

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-comment {
  color: #888888;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-family: "Iosevka Slab Light";
}


/* User color: hue: 0 */

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-family: "Iosevka Slab Light";
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}


/* Language color: hue: 90; */

.hljs-literal {
  color: #78A960;
}

.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300;
}


/* Meta color: hue: 200 */

.hljs-meta {
  color: #1f7199;
}

.hljs-meta-string {
  color: #4d99bf;
}


/* Misc effects */

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-family: "Iosevka Slab Light";
}
</style><style></style><script>/*
  Highlight.js 10.1.2 (edd73d24)
  License: BSD-3-Clause
  Copyright (c) 2006-2020, Ivan Sagalaev
*/
var hljs=function(){"use strict";function e(n){Object.freeze(n);var t="function"==typeof n;return Object.getOwnPropertyNames(n).forEach((function(r){!Object.hasOwnProperty.call(n,r)||null===n[r]||"object"!=typeof n[r]&&"function"!=typeof n[r]||t&&("caller"===r||"callee"===r||"arguments"===r)||Object.isFrozen(n[r])||e(n[r])})),n}class n{constructor(e){void 0===e.data&&(e.data={}),this.data=e.data}ignoreMatch(){this.ignore=!0}}function t(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")}function r(e,...n){var t={};for(const n in e)t[n]=e[n];return n.forEach((function(e){for(const n in e)t[n]=e[n]})),t}function a(e){return e.nodeName.toLowerCase()}var i=Object.freeze({__proto__:null,escapeHTML:t,inherit:r,nodeStream:function(e){var n=[];return function e(t,r){for(var i=t.firstChild;i;i=i.nextSibling)3===i.nodeType?r+=i.nodeValue.length:1===i.nodeType&&(n.push({event:"start",offset:r,node:i}),r=e(i,r),a(i).match(/br|hr|img|input/)||n.push({event:"stop",offset:r,node:i}));return r}(e,0),n},mergeStreams:function(e,n,r){var i=0,s="",o=[];function l(){return e.length&&n.length?e[0].offset!==n[0].offset?e[0].offset<n[0].offset?e:n:"start"===n[0].event?e:n:e.length?e:n}function c(e){s+="<"+a(e)+[].map.call(e.attributes,(function(e){return" "+e.nodeName+'="'+t(e.value)+'"'})).join("")+">"}function u(e){s+="</"+a(e)+">"}function d(e){("start"===e.event?c:u)(e.node)}for(;e.length||n.length;){var g=l();if(s+=t(r.substring(i,g[0].offset)),i=g[0].offset,g===e){o.reverse().forEach(u);do{d(g.splice(0,1)[0]),g=l()}while(g===e&&g.length&&g[0].offset===i);o.reverse().forEach(c)}else"start"===g[0].event?o.push(g[0].node):o.pop(),d(g.splice(0,1)[0])}return s+t(r.substr(i))}});const s="</span>",o=e=>!!e.kind;class l{constructor(e,n){this.buffer="",this.classPrefix=n.classPrefix,e.walk(this)}addText(e){this.buffer+=t(e)}openNode(e){if(!o(e))return;let n=e.kind;e.sublanguage||(n=`${this.classPrefix}${n}`),this.span(n)}closeNode(e){o(e)&&(this.buffer+=s)}value(){return this.buffer}span(e){this.buffer+=`<span class="${e}">`}}class c{constructor(){this.rootNode={children:[]},this.stack=[this.rootNode]}get top(){return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(e){this.top.children.push(e)}openNode(e){const n={kind:e,children:[]};this.add(n),this.stack.push(n)}closeNode(){if(this.stack.length>1)return this.stack.pop()}closeAllNodes(){for(;this.closeNode(););}toJSON(){return JSON.stringify(this.rootNode,null,4)}walk(e){return this.constructor._walk(e,this.rootNode)}static _walk(e,n){return"string"==typeof n?e.addText(n):n.children&&(e.openNode(n),n.children.forEach(n=>this._walk(e,n)),e.closeNode(n)),e}static _collapse(e){"string"!=typeof e&&e.children&&(e.children.every(e=>"string"==typeof e)?e.children=[e.children.join("")]:e.children.forEach(e=>{c._collapse(e)}))}}class u extends c{constructor(e){super(),this.options=e}addKeyword(e,n){""!==e&&(this.openNode(n),this.addText(e),this.closeNode())}addText(e){""!==e&&this.add(e)}addSublanguage(e,n){const t=e.root;t.kind=n,t.sublanguage=!0,this.add(t)}toHTML(){return new l(this,this.options).value()}finalize(){return!0}}function d(e){return e?"string"==typeof e?e:e.source:null}const g="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",h={begin:"\\\\[\\s\\S]",relevance:0},f={className:"string",begin:"'",end:"'",illegal:"\\n",contains:[h]},p={className:"string",begin:'"',end:'"',illegal:"\\n",contains:[h]},b={begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},m=function(e,n,t={}){var a=r({className:"comment",begin:e,end:n,contains:[]},t);return a.contains.push(b),a.contains.push({className:"doctag",begin:"(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",relevance:0}),a},v=m("//","$"),x=m("/\\*","\\*/"),E=m("#","$");var _=Object.freeze({__proto__:null,IDENT_RE:"[a-zA-Z]\\w*",UNDERSCORE_IDENT_RE:"[a-zA-Z_]\\w*",NUMBER_RE:"\\b\\d+(\\.\\d+)?",C_NUMBER_RE:g,BINARY_NUMBER_RE:"\\b(0b[01]+)",RE_STARTERS_RE:"!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",SHEBANG:(e={})=>{const n=/^#![ ]*\//;return e.binary&&(e.begin=function(...e){return e.map(e=>d(e)).join("")}(n,/.*\b/,e.binary,/\b.*/)),r({className:"meta",begin:n,end:/$/,relevance:0,"on:begin":(e,n)=>{0!==e.index&&n.ignoreMatch()}},e)},BACKSLASH_ESCAPE:h,APOS_STRING_MODE:f,QUOTE_STRING_MODE:p,PHRASAL_WORDS_MODE:b,COMMENT:m,C_LINE_COMMENT_MODE:v,C_BLOCK_COMMENT_MODE:x,HASH_COMMENT_MODE:E,NUMBER_MODE:{className:"number",begin:"\\b\\d+(\\.\\d+)?",relevance:0},C_NUMBER_MODE:{className:"number",begin:g,relevance:0},BINARY_NUMBER_MODE:{className:"number",begin:"\\b(0b[01]+)",relevance:0},CSS_NUMBER_MODE:{className:"number",begin:"\\b\\d+(\\.\\d+)?(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",relevance:0},REGEXP_MODE:{begin:/(?=\/[^/\n]*\/)/,contains:[{className:"regexp",begin:/\//,end:/\/[gimuy]*/,illegal:/\n/,contains:[h,{begin:/\[/,end:/\]/,relevance:0,contains:[h]}]}]},TITLE_MODE:{className:"title",begin:"[a-zA-Z]\\w*",relevance:0},UNDERSCORE_TITLE_MODE:{className:"title",begin:"[a-zA-Z_]\\w*",relevance:0},METHOD_GUARD:{begin:"\\.\\s*[a-zA-Z_]\\w*",relevance:0},END_SAME_AS_BEGIN:function(e){return Object.assign(e,{"on:begin":(e,n)=>{n.data._beginMatch=e[1]},"on:end":(e,n)=>{n.data._beginMatch!==e[1]&&n.ignoreMatch()}})}}),N="of and for in not or if then".split(" ");function w(e,n){return n?+n:function(e){return N.includes(e.toLowerCase())}(e)?0:1}const R=t,y=r,{nodeStream:O,mergeStreams:k}=i,M=Symbol("nomatch");return function(t){var a=[],i=Object.create(null),s=Object.create(null),o=[],l=!0,c=/(^(<[^>]+>|\t|)+|\n)/gm,g="Could not find the language '{}', did you forget to load/include a language module?";const h={disableAutodetect:!0,name:"Plain text",contains:[]};var f={noHighlightRe:/^(no-?highlight)$/i,languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:null,__emitter:u};function p(e){return f.noHighlightRe.test(e)}function b(e,n,t,r){var a={code:n,language:e};S("before:highlight",a);var i=a.result?a.result:m(a.language,a.code,t,r);return i.code=a.code,S("after:highlight",i),i}function m(e,t,a,s){var o=t;function c(e,n){var t=E.case_insensitive?n[0].toLowerCase():n[0];return Object.prototype.hasOwnProperty.call(e.keywords,t)&&e.keywords[t]}function u(){null!=y.subLanguage?function(){if(""!==A){var e=null;if("string"==typeof y.subLanguage){if(!i[y.subLanguage])return void k.addText(A);e=m(y.subLanguage,A,!0,O[y.subLanguage]),O[y.subLanguage]=e.top}else e=v(A,y.subLanguage.length?y.subLanguage:null);y.relevance>0&&(I+=e.relevance),k.addSublanguage(e.emitter,e.language)}}():function(){if(!y.keywords)return void k.addText(A);let e=0;y.keywordPatternRe.lastIndex=0;let n=y.keywordPatternRe.exec(A),t="";for(;n;){t+=A.substring(e,n.index);const r=c(y,n);if(r){const[e,a]=r;k.addText(t),t="",I+=a,k.addKeyword(n[0],e)}else t+=n[0];e=y.keywordPatternRe.lastIndex,n=y.keywordPatternRe.exec(A)}t+=A.substr(e),k.addText(t)}(),A=""}function h(e){return e.className&&k.openNode(e.className),y=Object.create(e,{parent:{value:y}})}function p(e){return 0===y.matcher.regexIndex?(A+=e[0],1):(L=!0,0)}var b={};function x(t,r){var i=r&&r[0];if(A+=t,null==i)return u(),0;if("begin"===b.type&&"end"===r.type&&b.index===r.index&&""===i){if(A+=o.slice(r.index,r.index+1),!l){const n=Error("0 width match regex");throw n.languageName=e,n.badRule=b.rule,n}return 1}if(b=r,"begin"===r.type)return function(e){var t=e[0],r=e.rule;const a=new n(r),i=[r.__beforeBegin,r["on:begin"]];for(const n of i)if(n&&(n(e,a),a.ignore))return p(t);return r&&r.endSameAsBegin&&(r.endRe=RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"),"m")),r.skip?A+=t:(r.excludeBegin&&(A+=t),u(),r.returnBegin||r.excludeBegin||(A=t)),h(r),r.returnBegin?0:t.length}(r);if("illegal"===r.type&&!a){const e=Error('Illegal lexeme "'+i+'" for mode "'+(y.className||"<unnamed>")+'"');throw e.mode=y,e}if("end"===r.type){var s=function(e){var t=e[0],r=o.substr(e.index),a=function e(t,r,a){let i=function(e,n){var t=e&&e.exec(n);return t&&0===t.index}(t.endRe,a);if(i){if(t["on:end"]){const e=new n(t);t["on:end"](r,e),e.ignore&&(i=!1)}if(i){for(;t.endsParent&&t.parent;)t=t.parent;return t}}if(t.endsWithParent)return e(t.parent,r,a)}(y,e,r);if(!a)return M;var i=y;i.skip?A+=t:(i.returnEnd||i.excludeEnd||(A+=t),u(),i.excludeEnd&&(A=t));do{y.className&&k.closeNode(),y.skip||y.subLanguage||(I+=y.relevance),y=y.parent}while(y!==a.parent);return a.starts&&(a.endSameAsBegin&&(a.starts.endRe=a.endRe),h(a.starts)),i.returnEnd?0:t.length}(r);if(s!==M)return s}if("illegal"===r.type&&""===i)return 1;if(B>1e5&&B>3*r.index)throw Error("potential infinite loop, way more iterations than matches");return A+=i,i.length}var E=T(e);if(!E)throw console.error(g.replace("{}",e)),Error('Unknown language: "'+e+'"');var _=function(e){function n(n,t){return RegExp(d(n),"m"+(e.case_insensitive?"i":"")+(t?"g":""))}class t{constructor(){this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}addRule(e,n){n.position=this.position++,this.matchIndexes[this.matchAt]=n,this.regexes.push([n,e]),this.matchAt+=function(e){return RegExp(e.toString()+"|").exec("").length-1}(e)+1}compile(){0===this.regexes.length&&(this.exec=()=>null);const e=this.regexes.map(e=>e[1]);this.matcherRe=n(function(e,n="|"){for(var t=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./,r=0,a="",i=0;i<e.length;i++){var s=r+=1,o=d(e[i]);for(i>0&&(a+=n),a+="(";o.length>0;){var l=t.exec(o);if(null==l){a+=o;break}a+=o.substring(0,l.index),o=o.substring(l.index+l[0].length),"\\"===l[0][0]&&l[1]?a+="\\"+(+l[1]+s):(a+=l[0],"("===l[0]&&r++)}a+=")"}return a}(e),!0),this.lastIndex=0}exec(e){this.matcherRe.lastIndex=this.lastIndex;const n=this.matcherRe.exec(e);if(!n)return null;const t=n.findIndex((e,n)=>n>0&&void 0!==e),r=this.matchIndexes[t];return n.splice(0,t),Object.assign(n,r)}}class a{constructor(){this.rules=[],this.multiRegexes=[],this.count=0,this.lastIndex=0,this.regexIndex=0}getMatcher(e){if(this.multiRegexes[e])return this.multiRegexes[e];const n=new t;return this.rules.slice(e).forEach(([e,t])=>n.addRule(e,t)),n.compile(),this.multiRegexes[e]=n,n}considerAll(){this.regexIndex=0}addRule(e,n){this.rules.push([e,n]),"begin"===n.type&&this.count++}exec(e){const n=this.getMatcher(this.regexIndex);n.lastIndex=this.lastIndex;const t=n.exec(e);return t&&(this.regexIndex+=t.position+1,this.regexIndex===this.count&&(this.regexIndex=0)),t}}function i(e,n){const t=e.input[e.index-1],r=e.input[e.index+e[0].length];"."!==t&&"."!==r||n.ignoreMatch()}if(e.contains&&e.contains.includes("self"))throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");return function t(s,o){const l=s;if(s.compiled)return l;s.compiled=!0,s.__beforeBegin=null,s.keywords=s.keywords||s.beginKeywords;let c=null;if("object"==typeof s.keywords&&(c=s.keywords.$pattern,delete s.keywords.$pattern),s.keywords&&(s.keywords=function(e,n){var t={};return"string"==typeof e?r("keyword",e):Object.keys(e).forEach((function(n){r(n,e[n])})),t;function r(e,r){n&&(r=r.toLowerCase()),r.split(" ").forEach((function(n){var r=n.split("|");t[r[0]]=[e,w(r[0],r[1])]}))}}(s.keywords,e.case_insensitive)),s.lexemes&&c)throw Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");return l.keywordPatternRe=n(s.lexemes||c||/\w+/,!0),o&&(s.beginKeywords&&(s.begin="\\b("+s.beginKeywords.split(" ").join("|")+")(?=\\b|\\s)",s.__beforeBegin=i),s.begin||(s.begin=/\B|\b/),l.beginRe=n(s.begin),s.endSameAsBegin&&(s.end=s.begin),s.end||s.endsWithParent||(s.end=/\B|\b/),s.end&&(l.endRe=n(s.end)),l.terminator_end=d(s.end)||"",s.endsWithParent&&o.terminator_end&&(l.terminator_end+=(s.end?"|":"")+o.terminator_end)),s.illegal&&(l.illegalRe=n(s.illegal)),void 0===s.relevance&&(s.relevance=1),s.contains||(s.contains=[]),s.contains=[].concat(...s.contains.map((function(e){return function(e){return e.variants&&!e.cached_variants&&(e.cached_variants=e.variants.map((function(n){return r(e,{variants:null},n)}))),e.cached_variants?e.cached_variants:function e(n){return!!n&&(n.endsWithParent||e(n.starts))}(e)?r(e,{starts:e.starts?r(e.starts):null}):Object.isFrozen(e)?r(e):e}("self"===e?s:e)}))),s.contains.forEach((function(e){t(e,l)})),s.starts&&t(s.starts,o),l.matcher=function(e){const n=new a;return e.contains.forEach(e=>n.addRule(e.begin,{rule:e,type:"begin"})),e.terminator_end&&n.addRule(e.terminator_end,{type:"end"}),e.illegal&&n.addRule(e.illegal,{type:"illegal"}),n}(l),l}(e)}(E),N="",y=s||_,O={},k=new f.__emitter(f);!function(){for(var e=[],n=y;n!==E;n=n.parent)n.className&&e.unshift(n.className);e.forEach(e=>k.openNode(e))}();var A="",I=0,S=0,B=0,L=!1;try{for(y.matcher.considerAll();;){B++,L?L=!1:(y.matcher.lastIndex=S,y.matcher.considerAll());const e=y.matcher.exec(o);if(!e)break;const n=x(o.substring(S,e.index),e);S=e.index+n}return x(o.substr(S)),k.closeAllNodes(),k.finalize(),N=k.toHTML(),{relevance:I,value:N,language:e,illegal:!1,emitter:k,top:y}}catch(n){if(n.message&&n.message.includes("Illegal"))return{illegal:!0,illegalBy:{msg:n.message,context:o.slice(S-100,S+100),mode:n.mode},sofar:N,relevance:0,value:R(o),emitter:k};if(l)return{illegal:!1,relevance:0,value:R(o),emitter:k,language:e,top:y,errorRaised:n};throw n}}function v(e,n){n=n||f.languages||Object.keys(i);var t=function(e){const n={relevance:0,emitter:new f.__emitter(f),value:R(e),illegal:!1,top:h};return n.emitter.addText(e),n}(e),r=t;return n.filter(T).filter(I).forEach((function(n){var a=m(n,e,!1);a.language=n,a.relevance>r.relevance&&(r=a),a.relevance>t.relevance&&(r=t,t=a)})),r.language&&(t.second_best=r),t}function x(e){return f.tabReplace||f.useBR?e.replace(c,e=>"\n"===e?f.useBR?"<br>":e:f.tabReplace?e.replace(/\t/g,f.tabReplace):e):e}function E(e){let n=null;const t=function(e){var n=e.className+" ";n+=e.parentNode?e.parentNode.className:"";const t=f.languageDetectRe.exec(n);if(t){var r=T(t[1]);return r||(console.warn(g.replace("{}",t[1])),console.warn("Falling back to no-highlight mode for this block.",e)),r?t[1]:"no-highlight"}return n.split(/\s+/).find(e=>p(e)||T(e))}(e);if(p(t))return;S("before:highlightBlock",{block:e,language:t}),f.useBR?(n=document.createElement("div")).innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ /]*>/g,"\n"):n=e;const r=n.textContent,a=t?b(t,r,!0):v(r),i=O(n);if(i.length){const e=document.createElement("div");e.innerHTML=a.value,a.value=k(i,O(e),r)}a.value=x(a.value),S("after:highlightBlock",{block:e,result:a}),e.innerHTML=a.value,e.className=function(e,n,t){var r=n?s[n]:t,a=[e.trim()];return e.match(/\bhljs\b/)||a.push("hljs"),e.includes(r)||a.push(r),a.join(" ").trim()}(e.className,t,a.language),e.result={language:a.language,re:a.relevance,relavance:a.relevance},a.second_best&&(e.second_best={language:a.second_best.language,re:a.second_best.relevance,relavance:a.second_best.relevance})}const N=()=>{if(!N.called){N.called=!0;var e=document.querySelectorAll("pre code");a.forEach.call(e,E)}};function T(e){return e=(e||"").toLowerCase(),i[e]||i[s[e]]}function A(e,{languageName:n}){"string"==typeof e&&(e=[e]),e.forEach(e=>{s[e]=n})}function I(e){var n=T(e);return n&&!n.disableAutodetect}function S(e,n){var t=e;o.forEach((function(e){e[t]&&e[t](n)}))}Object.assign(t,{highlight:b,highlightAuto:v,fixMarkup:x,highlightBlock:E,configure:function(e){f=y(f,e)},initHighlighting:N,initHighlightingOnLoad:function(){window.addEventListener("DOMContentLoaded",N,!1)},registerLanguage:function(e,n){var r=null;try{r=n(t)}catch(n){if(console.error("Language definition for '{}' could not be registered.".replace("{}",e)),!l)throw n;console.error(n),r=h}r.name||(r.name=e),i[e]=r,r.rawDefinition=n.bind(null,t),r.aliases&&A(r.aliases,{languageName:e})},listLanguages:function(){return Object.keys(i)},getLanguage:T,registerAliases:A,requireLanguage:function(e){var n=T(e);if(n)return n;throw Error("The '{}' language is required, but not loaded.".replace("{}",e))},autoDetection:I,inherit:y,addPlugin:function(e){o.push(e)}}),t.debugMode=function(){l=!1},t.safeMode=function(){l=!0},t.versionString="10.1.2";for(const n in _)"object"==typeof _[n]&&e(_[n]);return Object.assign(t,_),t}({})}();"object"==typeof exports&&"undefined"!=typeof module&&(module.exports=hljs);hljs.registerLanguage("makefile",function(){"use strict";return function(e){var i={className:"variable",variants:[{begin:"\\$\\("+e.UNDERSCORE_IDENT_RE+"\\)",contains:[e.BACKSLASH_ESCAPE]},{begin:/\$[@%<?\^\+\*]/}]},n={className:"string",begin:/"/,end:/"/,contains:[e.BACKSLASH_ESCAPE,i]},a={className:"variable",begin:/\$\([\w-]+\s/,end:/\)/,keywords:{built_in:"subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value"},contains:[i]},r={begin:"^"+e.UNDERSCORE_IDENT_RE+"\\s*(?=[:+?]?=)"},s={className:"section",begin:/^[^\s]+:/,end:/$/,contains:[i]};return{name:"Makefile",aliases:["mk","mak"],keywords:{$pattern:/[\w-]+/,keyword:"define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"},contains:[e.HASH_COMMENT_MODE,i,n,a,r,{className:"meta",begin:/^\.PHONY:/,end:/$/,keywords:{$pattern:/[\.\w]+/,"meta-keyword":".PHONY"}},s]}}}());hljs.registerLanguage("c-like",function(){"use strict";return function(e){function t(e){return"(?:"+e+")?"}var n="(decltype\\(auto\\)|"+t("[a-zA-Z_]\\w*::")+"[a-zA-Z_]\\w*"+t("<.*?>")+")",r={className:"keyword",begin:"\\b[a-z\\d_]*_t\\b"},a={className:"string",variants:[{begin:'(u8?|U|L)?"',end:'"',illegal:"\\n",contains:[e.BACKSLASH_ESCAPE]},{begin:"(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",end:"'",illegal:"."},e.END_SAME_AS_BEGIN({begin:/(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,end:/\)([^()\\ ]{0,16})"/})]},i={className:"number",variants:[{begin:"\\b(0b[01']+)"},{begin:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"},{begin:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],relevance:0},s={className:"meta",begin:/#\s*[a-z]+\b/,end:/$/,keywords:{"meta-keyword":"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"},contains:[{begin:/\\\n/,relevance:0},e.inherit(a,{className:"meta-string"}),{className:"meta-string",begin:/<.*?>/,end:/$/,illegal:"\\n"},e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE]},o={className:"title",begin:t("[a-zA-Z_]\\w*::")+e.IDENT_RE,relevance:0},c=t("[a-zA-Z_]\\w*::")+e.IDENT_RE+"\\s*\\(",l={keyword:"int float while private char char8_t char16_t char32_t catch import module export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using asm case typeid wchar_t short reinterpret_cast|10 default double register explicit signed typename try this switch continue inline delete alignas alignof constexpr consteval constinit decltype concept co_await co_return co_yield requires noexcept static_assert thread_local restrict final override atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong new throw return and and_eq bitand bitor compl not not_eq or or_eq xor xor_eq",built_in:"std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr _Bool complex _Complex imaginary _Imaginary",literal:"true false nullptr NULL"},d=[r,e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,i,a],_={variants:[{begin:/=/,end:/;/},{begin:/\(/,end:/\)/},{beginKeywords:"new throw return else",end:/;/}],keywords:l,contains:d.concat([{begin:/\(/,end:/\)/,keywords:l,contains:d.concat(["self"]),relevance:0}]),relevance:0},u={className:"function",begin:"("+n+"[\\*&\\s]+)+"+c,returnBegin:!0,end:/[{;=]/,excludeEnd:!0,keywords:l,illegal:/[^\w\s\*&:<>]/,contains:[{begin:"decltype\\(auto\\)",keywords:l,relevance:0},{begin:c,returnBegin:!0,contains:[o],relevance:0},{className:"params",begin:/\(/,end:/\)/,keywords:l,relevance:0,contains:[e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,a,i,r,{begin:/\(/,end:/\)/,keywords:l,relevance:0,contains:["self",e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,a,i,r]}]},r,e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,s]};return{aliases:["c","cc","h","c++","h++","hpp","hh","hxx","cxx"],keywords:l,disableAutodetect:!0,illegal:"</",contains:[].concat(_,u,d,[s,{begin:"\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",end:">",keywords:l,contains:["self",r]},{begin:e.IDENT_RE+"::",keywords:l},{className:"class",beginKeywords:"class struct",end:/[{;:]/,contains:[{begin:/</,end:/>/,contains:["self"]},e.TITLE_MODE]}]),exports:{preprocessor:s,strings:a,keywords:l}}}}());hljs.registerLanguage("cpp",function(){"use strict";return function(e){var t=e.getLanguage("c-like").rawDefinition();return t.disableAutodetect=!1,t.name="C++",t.aliases=["cc","c++","h++","hpp","hh","hxx","cxx"],t}}());hljs.registerLanguage("properties",function(){"use strict";return function(e){var n="[ \\t\\f]*",t="("+n+"[:=]"+n+"|[ \\t\\f]+)",a="([^\\\\:= \\t\\f\\n]|\\\\.)+",s={end:t,relevance:0,starts:{className:"string",end:/$/,relevance:0,contains:[{begin:"\\\\\\n"}]}};return{name:".properties",case_insensitive:!0,illegal:/\S/,contains:[e.COMMENT("^\\s*[!#]","$"),{begin:"([^\\\\\\W:= \\t\\f\\n]|\\\\.)+"+t,returnBegin:!0,contains:[{className:"attr",begin:"([^\\\\\\W:= \\t\\f\\n]|\\\\.)+",endsParent:!0,relevance:0}],starts:s},{begin:a+t,returnBegin:!0,relevance:0,contains:[{className:"meta",begin:a,endsParent:!0,relevance:0}],starts:s},{className:"attr",relevance:0,begin:a+n+"$"}]}}}());hljs.registerLanguage("c",function(){"use strict";return function(e){var n=e.getLanguage("c-like").rawDefinition();return n.name="C",n.aliases=["c","h"],n}}());hljs.registerLanguage("python",function(){"use strict";return function(e){var n={keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda async await nonlocal|10",built_in:"Ellipsis NotImplemented",literal:"False None True"},a={className:"meta",begin:/^(>>>|\.\.\.) /},i={className:"subst",begin:/\{/,end:/\}/,keywords:n,illegal:/#/},s={begin:/\{\{/,relevance:0},r={className:"string",contains:[e.BACKSLASH_ESCAPE],variants:[{begin:/(u|b)?r?'''/,end:/'''/,contains:[e.BACKSLASH_ESCAPE,a],relevance:10},{begin:/(u|b)?r?"""/,end:/"""/,contains:[e.BACKSLASH_ESCAPE,a],relevance:10},{begin:/(fr|rf|f)'''/,end:/'''/,contains:[e.BACKSLASH_ESCAPE,a,s,i]},{begin:/(fr|rf|f)"""/,end:/"""/,contains:[e.BACKSLASH_ESCAPE,a,s,i]},{begin:/(u|r|ur)'/,end:/'/,relevance:10},{begin:/(u|r|ur)"/,end:/"/,relevance:10},{begin:/(b|br)'/,end:/'/},{begin:/(b|br)"/,end:/"/},{begin:/(fr|rf|f)'/,end:/'/,contains:[e.BACKSLASH_ESCAPE,s,i]},{begin:/(fr|rf|f)"/,end:/"/,contains:[e.BACKSLASH_ESCAPE,s,i]},e.APOS_STRING_MODE,e.QUOTE_STRING_MODE]},l={className:"number",relevance:0,variants:[{begin:e.BINARY_NUMBER_RE+"[lLjJ]?"},{begin:"\\b(0o[0-7]+)[lLjJ]?"},{begin:e.C_NUMBER_RE+"[lLjJ]?"}]},t={className:"params",variants:[{begin:/\(\s*\)/,skip:!0,className:null},{begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,contains:["self",a,l,r,e.HASH_COMMENT_MODE]}]};return i.contains=[r,l,a],{name:"Python",aliases:["py","gyp","ipython"],keywords:n,illegal:/(<\/|->|\?)|=>/,contains:[a,l,{beginKeywords:"if",relevance:0},r,e.HASH_COMMENT_MODE,{variants:[{className:"function",beginKeywords:"def"},{className:"class",beginKeywords:"class"}],end:/:/,illegal:/[${=;\n,]/,contains:[e.UNDERSCORE_TITLE_MODE,t,{begin:/->/,endsWithParent:!0,keywords:"None"}]},{className:"meta",begin:/^[\t ]*@/,end:/$/},{begin:/\b(print|exec)\(/}]}}}());hljs.registerLanguage("bash",function(){"use strict";return function(e){const s={};Object.assign(s,{className:"variable",variants:[{begin:/\$[\w\d#@][\w\d_]*/},{begin:/\$\{/,end:/\}/,contains:[{begin:/:-/,contains:[s]}]}]});const t={className:"subst",begin:/\$\(/,end:/\)/,contains:[e.BACKSLASH_ESCAPE]},n={className:"string",begin:/"/,end:/"/,contains:[e.BACKSLASH_ESCAPE,s,t]};t.contains.push(n);const a={begin:/\$\(\(/,end:/\)\)/,contains:[{begin:/\d+#[0-9a-f]+/,className:"number"},e.NUMBER_MODE,s]},i=e.SHEBANG({binary:"(fish|bash|zsh|sh|csh|ksh|tcsh|dash|scsh)",relevance:10}),c={className:"function",begin:/\w[\w\d_]*\s*\(\s*\)\s*\{/,returnBegin:!0,contains:[e.inherit(e.TITLE_MODE,{begin:/\w[\w\d_]*/})],relevance:0};return{name:"Bash",aliases:["sh","zsh"],keywords:{$pattern:/\b-?[a-z\._]+\b/,keyword:"if then else elif fi for while in do done case esac function",literal:"true false",built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp",_:"-ne -eq -lt -gt -f -d -e -s -l -a"},contains:[i,e.SHEBANG(),c,a,e.HASH_COMMENT_MODE,n,{className:"",begin:/\\"/},{className:"string",begin:/'/,end:/'/},s]}}}());</script><script>var toc = undefined;

function makeTOC( doc )
{
    var doc = doc || document;
    toc = doc.getElementById( 'toc' );
    var headings = [].slice.call( doc.body.querySelectorAll( 'h1, h2' ) );

    var cur = toc;
    var last = undefined;
    var level = 'h1';

    headings.forEach( function ( heading, index )
    {
        tagname = heading.tagName.toLowerCase();
        anchor = heading.parentNode;

        var link = doc.createElement( 'a' );
        link.setAttribute( 'href', '#' + anchor.getAttribute( 'name' ) );
        if ( tagname == 'h1' )
            link.setAttribute( 'onclick', 'clickTOC( event )' );
        link.textContent = heading.textContent;

        if ( tagname > level )
        {
            var ol = doc.createElement( 'ol' );
            last.appendChild( ol );
            cur = ol;
        }

        if ( tagname < level )
            cur = cur.parentNode.parentNode;

        level = tagname;

        var li = doc.createElement( 'li' );
        li.setAttribute( 'class', tagname );
        last = li;

        li.appendChild( link );
        cur.appendChild( li );
    } );
}

function clickTOC(e)
{
    var exp = [].slice.call( toc.querySelectorAll( '.expanded' ) );

    exp.forEach( function ( elem, idx )
    {
        elem.classList.remove( "expanded" );
    } );

    e.target.parentNode.classList.add( "expanded" );
}
</script><script>hljs.initHighlightingOnLoad();</script></head><body onload="makeTOC()"><ol id="toc"></ol><div><!-- paragraph -->
<!-- paragraph -->
<!-- paragraph -->
<a name="Pravidla a organizace"><h1>A Pravidla a organizace</h1></a> <div class="par">Tento dokument je sbírkou cvičení a komentovaných příkladů
zdrojového kódu. Každá kapitola odpovídá jednomu týdnu semestru a
tedy jednomu cvičení. Cvičení v prvním týdnu semestru („nulté“) je
určeno k seznámení se s výukovým prostředím, studijními materiály a
základními nástroji ekosystému.
<!-- paragraph -->
</div>
<div class="par">Každá část sbírky (zejména tedy všechny ukázky a příklady) jsou také
k dispozici jako samostatné soubory, které můžete upravovat a
spouštět. Této rozdělené verzi sbírky říkáme <em>zdrojový balík</em>.
Aktuální verzi<a class="anchor" id="foothead1" href="#footnote1"><sup>1</sup></a> (ve všech variantách) můžete získat dvěma způsoby:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>Ve <em><a href="https://is.muni.cz/auth/el/fi/podzim2023/PB152cv/um/">studijních materiálech</a></em> předmětu v ISu – soubory PDF ve
složce <code>text</code>, zdrojový balík ve složkách <code>00</code> (organizační
informace), <code>01</code> až <code>12</code> (jednotlivé kapitoly = týdny semestru),
dále <code>s1</code> až <code>s3</code> (sady úloh) a konečně ve složce <code>sol</code> vzorová
řešení. Doporučujeme soubory stahovat dávkově pomocí volby
„stáhnout jako ZIP“.
</li><li>Po přihlášení na studentský server <code>aisa</code> (buď za pomoci <code>ssh</code>
nebo <code>putty</code>) zadáním příkazu <code>pb152 update</code>. Všechny výše
uvedené složky pak naleznete ve složce <code>~/pb152</code>.
</li></ol>
Tato kapitola (složka) dále obsahuje <em>závazná</em> pravidla a
organizační pokyny. Než budete pokračovat, pozorně si je prosím
přečtěte.
<!-- paragraph -->
</div>
<div class="par">Pro komunikaci s organizátory kurzu slouží <em>diskusní fórum</em> v ISu
(více informací naleznete v části T.1). Nepište prosím organizátorům
ani cvičícím maily ohledně předmětu, nejste-li k tomu specificky
vyzváni. S žádostmi o výjimky ze studijních povinností, omluvenkami,
atp., se obracejte vždy na studijní oddělení.
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote1" href="#foothead1"><sup>1</sup></a><div class="par"> Studijní materiály budeme tento semestr doplňovat průběžně,  protože kurz prochází zásadní reorganizací. Než začnete pracovat  na přípravách nebo příkladech ze sady, vždy se prosím ujistěte, že  máte jejich aktuální verzi. Zadání příprav lze považovat za  finální počínaje půlnocí na pondělí odpovídajícího týdne, sady  podobně půlnocí na první pondělí odpovídajícího bloku. Pro první  týden tedy 18.9.2023 0:00 a první sadu 25.9.2023 0:00.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Pravidla a organizace/Přehled"><h2>A.1 Přehled </h2></a> <div class="par">Tento předmět sestává z cvičení, sad domácích úloh a závěrečného
praktického testu (kolokvia). Protože se jedná o „programovací“
předmět, většina práce v předmětu – a tedy i jeho hodnocení – se
bude zaměřovat na praktické programování. Je důležité, abyste
programovali co možná nejvíce, ideálně každý den, ale minimálně
několikrát každý týden. K tomu Vám budou sloužit příklady v této
sbírce (typicky se bude jednat o velmi malé programy v rozsahu
jednotek až desítek řádků, kterých byste měli být v průměru schopni
vyřešit několik za hodinu) a domácí úlohy, kterých budou za semestr
3 sady, a budou znatelně většího rozsahu (maximálně malé stovky
řádků). V obou případech bude v průběhu semestru stoupat náročnost –
je tedy důležité, abyste drželi krok a práci neodkládali na poslední
chvíli.
<!-- paragraph -->
</div>
<div class="par">Protože programování je těžké, bude i tento kurz těžký – je zcela
nezbytné vložit do něj odpovídající úsilí. Doufáme, že kurz úspěšně
absolvujete, a co je důležitější, že se v něm toho naučíte co
nejvíce. Je ale nutno podotknout, že i přes svou náročnost je tento
kurz jen malým krokem na dlouhé cestě.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Probíraná témata"><h3>A.1.1 Probíraná témata</h3></a> <div class="par">Předmět je rozdělen do 4 bloků (čtvrtý blok patří do zkouškového
období). Do každého bloku v semestru patří 4 kapitoly (témata) a
jim odpovídající 4 cvičení.
<!-- paragraph -->
</div>
<div class="par"><table class="">
<tr><td colspan="1" class="center"> bl. </td> <td colspan="1" class="vrule right">     </td> <td colspan="1" class="left"> téma                                  </td></tr>
<tr><td colspan="1" class="center hrule">  1  </td> <td colspan="1" class="vrule right hrule">  1. </td> <td colspan="1" class="left hrule"> základy práce se soubory              </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right">  2. </td> <td colspan="1" class="left"> sockety                               </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right">  3. </td> <td colspan="1" class="left"> čekání na událost                     </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right">  4. </td> <td colspan="1" class="left"> mapování souborů do paměti            </td></tr>
<tr><td colspan="1" class="center hrule">  2  </td> <td colspan="1" class="vrule right hrule">  5. </td> <td colspan="1" class="left hrule"> složky (adresáře)                     </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right">  6. </td> <td colspan="1" class="left"> síť                                   </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right">  7. </td> <td colspan="1" class="left"> spustitelné soubory                   </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right">  8. </td> <td colspan="1" class="left"> správa popisovačů souborů             </td></tr>
<tr><td colspan="1" class="center hrule">  3  </td> <td colspan="1" class="vrule right hrule">  9. </td> <td colspan="1" class="left hrule"> procesy                               </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right"> 10. </td> <td colspan="1" class="left"> vlákna                                </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right"> 11. </td> <td colspan="1" class="left"> synchronizace                         </td></tr>
<tr><td colspan="1" class="center">     </td> <td colspan="1" class="vrule right"> 12. </td> <td colspan="1" class="left"> opakování                             </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Organizace sbírky"><h3>A.1.2 Organizace sbírky</h3></a> <div class="par">V následujících sekcích naleznete detailnější informace a <em>závazná</em>
pravidla kurzu: doporučujeme Vám, abyste se s nimi důkladně
seznámili.<a class="anchor" id="foothead2" href="#footnote2"><sup>2</sup></a> Zbytek sbírky je pak rozdělen na části, které odpovídají
jednotlivým týdnům semestru. <em>Důležité:</em> během prvního týdne
semestru už budete řešit přípravy z první kapitoly, přestože první
cvičení je ve až v týdnu druhém. Nulté cvičení je volitelné a není
nijak hodnoceno.
<!-- paragraph -->
</div>
<div class="par">Kapitoly jsou číslovány podle témat z předchozí tabulky: ve druhém
týdnu semestru se tedy <em>ve cvičení</em> budeme zabývat tématy, ke kterým
jste v prvním týdnu vypracovali a odevzdali přípravy.
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote2" href="#foothead2"><sup>2</sup></a><div class="par"> Pravidla jsou velmi podobná těm v kurzu IB111, ale přesto si je  pozorně přečtěte.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Pravidla a organizace/Plán semestru"><h3>A.1.3 Plán semestru</h3></a> <div class="par">Tento kurz vyžaduje značnou aktivitu během semestru. V této sekci
naleznete přehled důležitých událostí formou kalendáře. Jednotlivé
události jsou značeny takto (bližší informace ke každé naleznete
v následujících odstavcích tohoto úvodu):
<!-- paragraph -->
</div>
<div class="par"><ul><li>„#X“    – číslo týdne v semestru,
</li><li>„cv0“   – tento týden běží „nulté“ cvičení (kapitola B),
</li><li>„cv1“   – tento týden probíhají cvičení ke kapitole 1,
</li><li>„X/v“   – mezivýsledek verity testů příprav ke kapitole X,
</li><li>„X/p“   – poslední termín odevzdání příprav ke kapitole X,
</li><li>„sX/Y“  – Yté kolo verity testů k sadě X,
</li><li>„sX/z₁“ – první kolo známek za kvalitu kódu sady X,
</li><li>„sX/op“ – termín pro opravná odevzdání sady X,
</li><li>„sX/z₂“ – finální známky za kvalitu kódu sady X,
</li><li>„test“  – termín programovacího testu.
</li></ul>
Nejdůležitější události jsou zvýrazněny: termíny odevzdání příprav a
poslední termín odevzdání úloh ze sad (obojí vždy o 23:59 uvedeného
dne).
<!-- paragraph -->
</div>
<div class="par"><table class="">
<tr><td colspan="8" class="right">                            září                             </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule">   Po  </td> <td colspan="1" class="vrule left hrule">   Út  </td> <td colspan="1" class="vrule left hrule">   St  </td> <td colspan="1" class="vrule left hrule">   Čt  </td> <td colspan="1" class="vrule left hrule">   Pá  </td> <td colspan="1" class="vrule left hrule">   So  </td> <td colspan="1" class="vrule left hrule">   Ne  </td></tr>
<tr><td colspan="1" class="right hrule">  #1 </td> <td colspan="1" class="vrule left hrule"> 18    </td> <td colspan="1" class="vrule left hrule"> 19    </td> <td colspan="1" class="vrule left hrule"> 20    </td> <td colspan="1" class="vrule left hrule"> 21    </td> <td colspan="1" class="vrule left hrule"> 22    </td> <td colspan="1" class="vrule left hrule"> 23    </td> <td colspan="1" class="vrule left hrule"> 24    </td></tr>
<tr><td colspan="1" class="right"> cv0 </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> 01/v  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"><em>01/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">  #2 </td> <td colspan="1" class="vrule left hrule"> 25    </td> <td colspan="1" class="vrule left hrule"> 26    </td> <td colspan="1" class="vrule left hrule"> 27    </td> <td colspan="1" class="vrule left hrule"> 28 sv </td> <td colspan="1" class="vrule left hrule"> 29    </td> <td colspan="1" class="vrule left hrule"> 30    </td> <td colspan="1" class="vrule left hrule">       </td></tr>
<tr><td colspan="1" class="right"> cv1 </td> <td colspan="1" class="vrule left"> s1/1  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s1/2  </td> <td colspan="1" class="vrule left"> 02/v  </td> <td colspan="1" class="vrule left"> s1/3  </td> <td colspan="1" class="vrule left"><em>02/p</em> </td> <td colspan="1" class="vrule left">       </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par"><table class="">
<tr><td colspan="8" class="right">                            říjen                            </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule">   Po  </td> <td colspan="1" class="vrule left hrule">   Út  </td> <td colspan="1" class="vrule left hrule">   St  </td> <td colspan="1" class="vrule left hrule">   Čt  </td> <td colspan="1" class="vrule left hrule">   Pá  </td> <td colspan="1" class="vrule left hrule">   So  </td> <td colspan="1" class="vrule left hrule">   Ne  </td></tr>
<tr><td colspan="1" class="right hrule">  #2 </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule"> 1     </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">  #3 </td> <td colspan="1" class="vrule left hrule"> 2     </td> <td colspan="1" class="vrule left hrule"> 3     </td> <td colspan="1" class="vrule left hrule"> 4     </td> <td colspan="1" class="vrule left hrule"> 5     </td> <td colspan="1" class="vrule left hrule"> 6     </td> <td colspan="1" class="vrule left hrule"> 7     </td> <td colspan="1" class="vrule left hrule"> 8     </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s1/4  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s1/5  </td> <td colspan="1" class="vrule left"> 03/v  </td> <td colspan="1" class="vrule left"> s1/6  </td> <td colspan="1" class="vrule left"><em>03/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">  #4 </td> <td colspan="1" class="vrule left hrule"> 9     </td> <td colspan="1" class="vrule left hrule"> 10    </td> <td colspan="1" class="vrule left hrule"> 11    </td> <td colspan="1" class="vrule left hrule"> 12    </td> <td colspan="1" class="vrule left hrule"> 13    </td> <td colspan="1" class="vrule left hrule"> 14    </td> <td colspan="1" class="vrule left hrule"> 15    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s1/7  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s1/8  </td> <td colspan="1" class="vrule left"> 04/v  </td> <td colspan="1" class="vrule left"> s1/9  </td> <td colspan="1" class="vrule left"><em>04/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">  #5 </td> <td colspan="1" class="vrule left hrule"> 16    </td> <td colspan="1" class="vrule left hrule"> 17    </td> <td colspan="1" class="vrule left hrule"> 18    </td> <td colspan="1" class="vrule left hrule"> 19    </td> <td colspan="1" class="vrule left hrule"> 20    </td> <td colspan="1" class="vrule left hrule"> 21    </td> <td colspan="1" class="vrule left hrule"> 22    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s1/10 </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s1/11 </td> <td colspan="1" class="vrule left"> 05/v  </td> <td colspan="1" class="vrule left"><em>s1/12</em></td> <td colspan="1" class="vrule left"><em>05/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">  #6 </td> <td colspan="1" class="vrule left hrule"> 23    </td> <td colspan="1" class="vrule left hrule"> 24    </td> <td colspan="1" class="vrule left hrule"> 25    </td> <td colspan="1" class="vrule left hrule"> 26    </td> <td colspan="1" class="vrule left hrule"> 27    </td> <td colspan="1" class="vrule left hrule"> 28 sv </td> <td colspan="1" class="vrule left hrule"> 29    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s2/1  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s2/2  </td> <td colspan="1" class="vrule left"> 06/v  </td> <td colspan="1" class="vrule left"> s2/3  </td> <td colspan="1" class="vrule left"><em>06/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">  #7 </td> <td colspan="1" class="vrule left hrule"> 30    </td> <td colspan="1" class="vrule left hrule"> 31    </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s2/4  </td> <td colspan="1" class="vrule left"> s1/z₁ </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par"><table class="">
<tr><td colspan="8" class="right">                          listopad                           </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule">   Po  </td> <td colspan="1" class="vrule left hrule">   Út  </td> <td colspan="1" class="vrule left hrule">   St  </td> <td colspan="1" class="vrule left hrule">   Čt  </td> <td colspan="1" class="vrule left hrule">   Pá  </td> <td colspan="1" class="vrule left hrule">   So  </td> <td colspan="1" class="vrule left hrule">   Ne  </td></tr>
<tr><td colspan="1" class="right hrule">  #7 </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule"> 1     </td> <td colspan="1" class="vrule left hrule"> 2     </td> <td colspan="1" class="vrule left hrule"> 3     </td> <td colspan="1" class="vrule left hrule"> 4     </td> <td colspan="1" class="vrule left hrule"> 5     </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s2/5  </td> <td colspan="1" class="vrule left"> 07/v  </td> <td colspan="1" class="vrule left"> s2/6  </td> <td colspan="1" class="vrule left"><em>07/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">  #8 </td> <td colspan="1" class="vrule left hrule"> 6     </td> <td colspan="1" class="vrule left hrule"> 7     </td> <td colspan="1" class="vrule left hrule"> 8     </td> <td colspan="1" class="vrule left hrule"> 9     </td> <td colspan="1" class="vrule left hrule"> 10    </td> <td colspan="1" class="vrule left hrule"> 11    </td> <td colspan="1" class="vrule left hrule"> 12    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s2/7  </td> <td colspan="1" class="vrule left"><em>s1/op</em></td> <td colspan="1" class="vrule left"> s2/8  </td> <td colspan="1" class="vrule left"> 08/v  </td> <td colspan="1" class="vrule left"> s2/9  </td> <td colspan="1" class="vrule left"><em>08/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">  #9 </td> <td colspan="1" class="vrule left hrule"> 13    </td> <td colspan="1" class="vrule left hrule"> 14    </td> <td colspan="1" class="vrule left hrule"> 15    </td> <td colspan="1" class="vrule left hrule"> 16    </td> <td colspan="1" class="vrule left hrule"> 17 sv </td> <td colspan="1" class="vrule left hrule"> 18    </td> <td colspan="1" class="vrule left hrule"> 19    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s2/10 </td> <td colspan="1" class="vrule left"> s1/z₂ </td> <td colspan="1" class="vrule left"> s2/11 </td> <td colspan="1" class="vrule left"> 09/v  </td> <td colspan="1" class="vrule left"><em>s2/12</em></td> <td colspan="1" class="vrule left"><em>09/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule"> #10 </td> <td colspan="1" class="vrule left hrule"> 20    </td> <td colspan="1" class="vrule left hrule"> 21    </td> <td colspan="1" class="vrule left hrule"> 22    </td> <td colspan="1" class="vrule left hrule"> 23    </td> <td colspan="1" class="vrule left hrule"> 24    </td> <td colspan="1" class="vrule left hrule"> 25    </td> <td colspan="1" class="vrule left hrule"> 26    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s3/1  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s3/2  </td> <td colspan="1" class="vrule left"> 10/v  </td> <td colspan="1" class="vrule left"> s3/3  </td> <td colspan="1" class="vrule left"><em>10/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule"> #11 </td> <td colspan="1" class="vrule left hrule"> 27    </td> <td colspan="1" class="vrule left hrule"> 28    </td> <td colspan="1" class="vrule left hrule"> 29    </td> <td colspan="1" class="vrule left hrule"> 30    </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s3/4  </td> <td colspan="1" class="vrule left"> s2/z₁ </td> <td colspan="1" class="vrule left"> s3/5  </td> <td colspan="1" class="vrule left"> 11/v  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par"><table class="">
<tr><td colspan="8" class="right">                          prosinec                           </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule">   Po  </td> <td colspan="1" class="vrule left hrule">   Út  </td> <td colspan="1" class="vrule left hrule">   St  </td> <td colspan="1" class="vrule left hrule">   Čt  </td> <td colspan="1" class="vrule left hrule">   Pá  </td> <td colspan="1" class="vrule left hrule">   So  </td> <td colspan="1" class="vrule left hrule">   Ne  </td></tr>
<tr><td colspan="1" class="right hrule"> #11 </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule"> 1     </td> <td colspan="1" class="vrule left hrule"> 2     </td> <td colspan="1" class="vrule left hrule"> 3     </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s3/6  </td> <td colspan="1" class="vrule left"><em>11/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule"> #12 </td> <td colspan="1" class="vrule left hrule"> 4     </td> <td colspan="1" class="vrule left hrule"> 5     </td> <td colspan="1" class="vrule left hrule"> 6     </td> <td colspan="1" class="vrule left hrule"> 7     </td> <td colspan="1" class="vrule left hrule"> 8     </td> <td colspan="1" class="vrule left hrule"> 9     </td> <td colspan="1" class="vrule left hrule"> 10    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s3/7  </td> <td colspan="1" class="vrule left"><em>s2/op</em></td> <td colspan="1" class="vrule left"> s3/8  </td> <td colspan="1" class="vrule left"> 12/v  </td> <td colspan="1" class="vrule left"> s3/9  </td> <td colspan="1" class="vrule left"><em>12/p</em> </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule"> #13 </td> <td colspan="1" class="vrule left hrule"> 11    </td> <td colspan="1" class="vrule left hrule"> 12    </td> <td colspan="1" class="vrule left hrule"> 13    </td> <td colspan="1" class="vrule left hrule"> 14    </td> <td colspan="1" class="vrule left hrule"> 15    </td> <td colspan="1" class="vrule left hrule"> 16    </td> <td colspan="1" class="vrule left hrule"> 17    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left"> s3/10 </td> <td colspan="1" class="vrule left"> s2/z₂ </td> <td colspan="1" class="vrule left"> s3/11 </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"><em>s3/12</em></td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 18    </td> <td colspan="1" class="vrule left hrule"> 19    </td> <td colspan="1" class="vrule left hrule"> 20    </td> <td colspan="1" class="vrule left hrule"> 21    </td> <td colspan="1" class="vrule left hrule"> 22    </td> <td colspan="1" class="vrule left hrule"> 23    </td> <td colspan="1" class="vrule left hrule"> 24    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 25    </td> <td colspan="1" class="vrule left hrule"> 26    </td> <td colspan="1" class="vrule left hrule"> 27    </td> <td colspan="1" class="vrule left hrule"> 28    </td> <td colspan="1" class="vrule left hrule"> 29    </td> <td colspan="1" class="vrule left hrule"> 30    </td> <td colspan="1" class="vrule left hrule"> 31    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par"><table class="">
<tr><td colspan="8" class="right">                            leden                            </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule">   Po  </td> <td colspan="1" class="vrule left hrule">   Út  </td> <td colspan="1" class="vrule left hrule">   St  </td> <td colspan="1" class="vrule left hrule">   Čt  </td> <td colspan="1" class="vrule left hrule">   Pá  </td> <td colspan="1" class="vrule left hrule">   So  </td> <td colspan="1" class="vrule left hrule">   Ne  </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 1     </td> <td colspan="1" class="vrule left hrule"> 2     </td> <td colspan="1" class="vrule left hrule"> 3     </td> <td colspan="1" class="vrule left hrule"> 4     </td> <td colspan="1" class="vrule left hrule"> 5     </td> <td colspan="1" class="vrule left hrule"> 6     </td> <td colspan="1" class="vrule left hrule"> 7     </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s3/z₁ </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 8     </td> <td colspan="1" class="vrule left hrule"> 9     </td> <td colspan="1" class="vrule left hrule"> 10    </td> <td colspan="1" class="vrule left hrule"> 11    </td> <td colspan="1" class="vrule left hrule"> 12    </td> <td colspan="1" class="vrule left hrule"> 13    </td> <td colspan="1" class="vrule left hrule"> 14    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"><em>s3/op</em></td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 15    </td> <td colspan="1" class="vrule left hrule"> 16    </td> <td colspan="1" class="vrule left hrule"> 17    </td> <td colspan="1" class="vrule left hrule"> 18    </td> <td colspan="1" class="vrule left hrule"> 19    </td> <td colspan="1" class="vrule left hrule"> 20    </td> <td colspan="1" class="vrule left hrule"> 21    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> s3/z₂ </td> <td colspan="1" class="vrule left"> test  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 22    </td> <td colspan="1" class="vrule left hrule"> 23    </td> <td colspan="1" class="vrule left hrule"> 24    </td> <td colspan="1" class="vrule left hrule"> 25    </td> <td colspan="1" class="vrule left hrule"> 26    </td> <td colspan="1" class="vrule left hrule"> 27    </td> <td colspan="1" class="vrule left hrule"> 28    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> test  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 29    </td> <td colspan="1" class="vrule left hrule"> 30    </td> <td colspan="1" class="vrule left hrule"> 31    </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> test  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par"><table class="">
<tr><td colspan="8" class="right">                            únor                             </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule">   Po  </td> <td colspan="1" class="vrule left hrule">   Út  </td> <td colspan="1" class="vrule left hrule">   St  </td> <td colspan="1" class="vrule left hrule">   Čt  </td> <td colspan="1" class="vrule left hrule">   Pá  </td> <td colspan="1" class="vrule left hrule">   So  </td> <td colspan="1" class="vrule left hrule">   Ne  </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule">       </td> <td colspan="1" class="vrule left hrule"> 1     </td> <td colspan="1" class="vrule left hrule"> 2     </td> <td colspan="1" class="vrule left hrule"> 3     </td> <td colspan="1" class="vrule left hrule"> 4     </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 5     </td> <td colspan="1" class="vrule left hrule"> 6     </td> <td colspan="1" class="vrule left hrule"> 7     </td> <td colspan="1" class="vrule left hrule"> 8     </td> <td colspan="1" class="vrule left hrule"> 9     </td> <td colspan="1" class="vrule left hrule"> 10    </td> <td colspan="1" class="vrule left hrule"> 11    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left"> test  </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr>
<tr><td colspan="1" class="right hrule">     </td> <td colspan="1" class="vrule left hrule"> 12    </td> <td colspan="1" class="vrule left hrule"> 13    </td> <td colspan="1" class="vrule left hrule"> 14    </td> <td colspan="1" class="vrule left hrule"> 15    </td> <td colspan="1" class="vrule left hrule"> 16    </td> <td colspan="1" class="vrule left hrule"> 17    </td> <td colspan="1" class="vrule left hrule"> 18    </td></tr>
<tr><td colspan="1" class="right">     </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td> <td colspan="1" class="vrule left">       </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<!-- paragraph -->
<a name="Pravidla a organizace/Hodnocení"><h2>A.2 Hodnocení </h2></a> <div class="par">Abyste předmět úspěšně ukončili, musíte v <em>každém bloku<a class="anchor" id="foothead3" href="#footnote3"><sup>3</sup></a></em> získat <em>60
bodů</em>. Žádné další požadavky nemáme.
<!-- paragraph -->
</div>
<div class="par">Body lze získat mnoha různými způsoby (přesnější podmínky naleznete
v následujících sekcích této kapitoly). V blocích 1-3 (probíhají
během semestru) jsou to:
<!-- paragraph -->
</div>
<div class="par"><ul><li>za každou úspěšně odevzdanou přípravu <em>1</em> bod (max. 6 bodů každý
týden, nebo <em>24/blok</em>),
</li><li>za každou přípravu, která projde „verity“ testy navíc <em>0,5</em> bodu
(max. 3 body každý týden, nebo <em>12/blok</em>),
</li><li>za účast<a class="anchor" id="foothead4" href="#footnote4"><sup>4</sup></a> na cvičení získáte 3 body (max. tedy <em>12/blok</em>),
</li><li>za aktivitu ve cvičení 3 body (max. tedy <em>12/blok</em>).
</li></ul>
Za přípravy a cvičení lze tedy získat teoretické maximum <em>60</em> bodů.
Dále můžete získat:
<!-- paragraph -->
</div>
<div class="par"><ul><li><em>10</em> bodů za úspěšně vyřešený příklad ze sady domácích úloh
(celkem vždy <em>60/blok</em>).
</li></ul>
V blocích 2-4 navíc můžete získat body za kvalitu řešení příkladů ze
sady úloh předchozího bloku:
<!-- paragraph -->
</div>
<div class="par"><ul><li>za kvalitu kódu max. <em>5</em> bodů za příklad (celkem <em>30/blok</em>).
</li></ul>
Konečně blok 4, který patří do zkouškového období, nemá ani cvičení
ani sadu domácích úloh. Krom bodů za kvalitu kódu ze třetí sady lze
získat:
<!-- paragraph -->
</div>
<div class="par"><ul><li><em>15</em> bodů za každý zkouškový příklad (celkem <em>90/blok</em>).
</li></ul>
Celkově tedy potřebujete:
<!-- paragraph -->
</div>
<div class="par"><ul><li>blok 1: <em>60/120</em> bodů,
</li><li>blok 2: <em>60/150</em> bodů,
</li><li>blok 3: <em>60/150</em> bodů,
</li><li>blok 4: <em>60/120</em> bodů (neplatí pro ukončení zápočtem).
</li></ul>
<!-- paragraph -->
</div>
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote3" href="#foothead3"><sup>3</sup></a><div class="par"> Máte-li předmět ukončen zápočtem, čtvrtý blok a tedy ani závěrečný  test pro Vás není relevantní. Platí požadavek na 3×60 bodů z bloků  v semestru.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote4" href="#foothead4"><sup>4</sup></a><div class="par"> V případě, že jste <em>řádně omluveni</em> v ISu, nebo Vaše cvičení  <em>odpadlo</em> (např. padlo na státní svátek), můžete body za účast  získat buď náhradou v jiné skupině (pro státní svátky dostanete  instrukce mailem, individuální případy si domluvte s cvičícími  obou dotčených skupin). Nemůžete-li účast nahradit takto,  <em>domluvte se</em> se svým cvičícím (v tomto případě lze i mailem) na  vypracování 3 rozšířených příkladů ze sbírky (přesné detaily Vám  sdělí cvičící podle konkrétní situace). Neomluvenou neúčast lze  nahrazovat <em>pouze</em> v jiné skupině a to max. 1–2× za semestr.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Pravidla a organizace/Přípravy"><h2>A.3 Přípravy </h2></a> <div class="par">Jak již bylo zmíněno, chcete-li se naučit programovat, musíte
programování věnovat nemalé množství času, a navíc musí být tento
čas rozložen do delších období – semestr nelze v žádném případě
doběhnout tím, že budete týden programovat 12 hodin denně, i když to
možná pokryje potřebný počet hodin. Proto od Vás budeme chtít,
abyste každý týden odevzdali několik vyřešených příkladů z této
sbírky. Tento požadavek má ještě jeden důvod: chceme, abyste vždy
v době cvičení už měli látku každý samostatně nastudovanou, abychom
mohli řešit zajímavé problémy, nikoliv opakovat základní pojmy.
<!-- paragraph -->
</div>
<div class="par">Také Vás prosíme, abyste příklady, které plánujete odevzdat, řešili
vždy samostatně: případnou zakázanou spolupráci budeme trestat (viz
také konec této kapitoly).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Odevzdání"><h3>A.3.1 Odevzdání </h3></a> <div class="par">Každý příklad obsahuje základní sadu testů. To, že Vám tyto testy
prochází, je jediné kritérium pro zisk základních bodů za odevzdání
příprav. Poté, co příklady odevzdáte, budou <em>tytéž testy</em> na Vašem
řešení automaticky spuštěny, a jejich výsledek Vám bude zapsán do
poznámkového bloku. Smyslem tohoto opatření je zamezit případům, kdy
omylem odevzdáte nesprávné, nebo jinak nevyhovující řešení, aniž
byste o tom věděli. Velmi silně Vám proto doporučujeme odevzdávat
s určitým předstihem, abyste případné nesrovnalosti měli ještě čas
vyřešit. Krom základních („sanity“) testů pak ve čtvrtek o 23:59 a
znovu v sobotu o 23:59 (těsně po konci odevzdávání) spustíme
<em>rozšířenou</em> sadu testů („verity“).
<!-- paragraph -->
</div>
<div class="par">Za každý odevzdaný příklad, který splnil <em>základní</em> („sanity“) testy
získáváte jeden bod. Za příklad, který navíc splnil <em>rozšířené</em>
testy získáte dalšího 0,5 bodu (tzn. celkem 1,5 bodu). Výsledky
testů naleznete v <em>poznámkovém bloku</em> v informačním systému.
<!-- paragraph -->
</div>
<div class="par">Příklady můžete odevzdávat:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>do <em>odevzdávárny</em> s názvem <code>NN</code> v ISu (např. <code>01</code>),
</li><li>příkazem <code>pb152 submit</code> ve složce <code>~/pb152/NN</code>.
</li></ol>
Podrobnější instrukce naleznete v kapitole T (technické informace,
soubory <code>00/t*</code>).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Harmonogram"><h3>A.3.2 Harmonogram </h3></a> <div class="par">Termíny pro odevzdání příprav k jednotlivým kapitolám jsou shrnuty
v následující tabulce:
<!-- paragraph -->
</div>
<div class="par"><table class="">
<tr><td colspan="1" class="center"> blok </td> <td colspan="1" class="vrule center"> kapitola </td> <td colspan="1" class="vrule center">  verity </td> <td colspan="1" class="vrule center">  termín </td></tr>
<tr><td colspan="1" class="center hrule">   1  </td> <td colspan="1" class="vrule center hrule">       1  </td> <td colspan="1" class="vrule center hrule">  21.9.  </td> <td colspan="1" class="vrule center hrule">  23.9.  </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">       2  </td> <td colspan="1" class="vrule center">  28.9.  </td> <td colspan="1" class="vrule center">  30.9.  </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">       3  </td> <td colspan="1" class="vrule center">   5.10. </td> <td colspan="1" class="vrule center">   7.10. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">       4  </td> <td colspan="1" class="vrule center">  12.10. </td> <td colspan="1" class="vrule center">  14.10. </td></tr>
<tr><td colspan="1" class="center hrule">   2  </td> <td colspan="1" class="vrule center hrule">       5  </td> <td colspan="1" class="vrule center hrule">  19.10. </td> <td colspan="1" class="vrule center hrule">  21.10. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">       6  </td> <td colspan="1" class="vrule center">  26.10. </td> <td colspan="1" class="vrule center">  28.10. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">       7  </td> <td colspan="1" class="vrule center">   2.11. </td> <td colspan="1" class="vrule center">   4.11. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">       8  </td> <td colspan="1" class="vrule center">   9.11. </td> <td colspan="1" class="vrule center">  11.11. </td></tr>
<tr><td colspan="1" class="center hrule">   3  </td> <td colspan="1" class="vrule center hrule">       9  </td> <td colspan="1" class="vrule center hrule">  16.11. </td> <td colspan="1" class="vrule center hrule">  18.11. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">      10  </td> <td colspan="1" class="vrule center">  23.11. </td> <td colspan="1" class="vrule center">  25.11. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">      11  </td> <td colspan="1" class="vrule center">  30.11. </td> <td colspan="1" class="vrule center">   2.12. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">      12  </td> <td colspan="1" class="vrule center">   7.12. </td> <td colspan="1" class="vrule center">   9.12. </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<!-- paragraph -->
<a name="Pravidla a organizace/Cvičení"><h2>A.4 Cvičení </h2></a> <div class="par">Těžiště tohoto předmětu je jednoznačně v samostatné domácí práci –
učit se programovat znamená zejména hodně programovat. Společná
cvičení sice nemohou tuto práci nahradit, mohou Vám ale přesto
v lecčem pomoct. Smyslem cvičení je:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>analyzovat problémy, na které jste při samostatné domácí práci
narazili, a zejména prodiskutovat, jak je vyřešit,
</li><li>řešit programátorské problémy společně (s cvičícím, ve dvojici,
ve skupině) – nahlédnout jak o programech a programování uvažují
ostatní a užitečné prvky si osvojit.
</li></ol>
Cvičení je rozděleno na dva podobně dlouhé segmenty, které
odpovídají těmto bodům. První část probíhá přibližně takto:
<!-- paragraph -->
</div>
<div class="par"><ul><li>cvičící vybere ty z Vámi odevzdaných příprav, které se mu zdají
něčím zajímavé – ať už v pozitivním, nebo negativním smyslu,

<ul><li>řešení bude <em>anonymně</em> promítat na plátno a u každého otevře
diskusi o tom, čím je zajímavé;
</li><li>Vaším úkolem je aktivně se do této diskuse zapojit (můžete se
například ptát proč je daná věc dobře nebo špatně a jak by se
udělala lépe, vyjádřit svůj názor, odpovídat na dotazy
cvičícího),
</li><li>k promítnutému řešení se můžete přihlásit a ostatním přiblížit,
proč je napsané tak jak je, nebo klidně i rozporovat případnou
kritiku (není to ale vůbec nutné),
</li></ul>
</li><li>dále podobným způsobem vybere vzájemné (peer) recenze, které jste
v předchozím týdnu psali, a stručně je s Vámi prodiskutuje
(celkovou strukturu recenze, proč je který komentář dobrý nebo
nikoliv, jestli nějaký komentář chybí, atp.) – opět se můžete
(resp. byste se měli) zapojovat,
</li><li>na Vaši žádost lze ve cvičení analogicky probrat <em>neúšpěšná</em>
řešení příkladů (a to jak příprav, tak příkladů z uzavřených
sad).
</li></ul>
Druhá část cvičení je variabilnější, ale bude se vždy točit kolem
bodů za aktivitu (každý týden můžete za aktivitu získat maximálně 3
body).
<!-- paragraph -->
</div>
<div class="par">Ve čtvrtém, osmém a dvanáctém týdnu proběhnou „vnitrosemestrálky“
kde budete řešit samostatně jeden příklad ze sbírky, bez možnosti
hledat na internetu – tak, jak to bude na závěrečném testu; každé
úspěšné řešení (tzn. takové, které splní verity testy) získá ony 3
body za aktivitu pro daný týden.
<!-- paragraph -->
</div>
<div class="par">V ostatních týdnech budete ve druhém segmentu kombinovat různé
aktivity, které budou postavené na příkladech typu <code>r</code> z aktuální
kapitoly (které konkrétní příklady budete ve cvičení řešit vybere
cvičící, může ale samozřejmě vzít v potaz Vaše preference):
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>Můžete se přihlásit k řešení příkladu na plátně, kdy primárně
vymýšlíte řešení Vy, ale zbytek třídy Vám bude podle potřeby
radit, nebo se ptát co/jak/proč se v řešení děje. U jednodušších
příkladů se od Vás bude také očekávat, že jako součást řešení
doplníte testy.
</li><li>Cvičící Vám může zadat práci ve dvojicích – první dvojice, která
se dopracuje k funkčnímu řešení získá možnost své řešení
předvést zbytku třídy – vysvětlit jak a proč funguje, odpovědět
na případné dotazy, opravit chyby, které v řešení publikum
najde, atp. – a získat tak body za aktivitu. Získané 3 body
budou rozděleny rovným dílem mezi vítězné řešitele.
</li><li>příklad můžete také řešit společně jako skupina – takto
vymyšlený kód bude zapisovat cvičící (body za aktivitu se
v tomto případě neudělují).
</li></ol>
<!-- paragraph -->
</div>
<a name="Pravidla a organizace/Sady domácích úloh"><h2>A.5 Sady domácích úloh</h2></a> <div class="par">Ke každému bloku patří sada 6 domácích úloh, které tvoří významnou
část hodnocení předmětu. Na úspěšné odevzdání každé domácí úlohy
budete mít 12 pokusů rozložených do 4 týdnů odpovídajícího bloku
cvičení. Odevzdávání bude otevřeno vždy v 0:00 prvního dne bloku
(tzn. 24h před prvním spuštěním verity testů).
<!-- paragraph -->
</div>
<div class="par">Termíny odevzdání (vyhodnocení verity testů) jsou vždy v pondělí,
středu a pátek v 23:59, dle následujícího harmonogramu:
<!-- paragraph -->
</div>
<div class="par"><table class="">
<tr><td colspan="1" class="center"> sada </td> <td colspan="1" class="vrule center"> týden </td> <td colspan="1" class="vrule right"> pondělí </td> <td colspan="1" class="right"> středa  </td> <td colspan="1" class="right"> pátek   </td></tr>
<tr><td colspan="1" class="center hrule">    1 </td> <td colspan="1" class="vrule center hrule">     1 </td> <td colspan="1" class="vrule right hrule">  25.9.  </td> <td colspan="1" class="right hrule">  27.9.  </td> <td colspan="1" class="right hrule">  29.9.  </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     2 </td> <td colspan="1" class="vrule right">   2.10. </td> <td colspan="1" class="right">   4.10. </td> <td colspan="1" class="right">   6.10. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     3 </td> <td colspan="1" class="vrule right">   9.10. </td> <td colspan="1" class="right">  11.10. </td> <td colspan="1" class="right">  13.10. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     4 </td> <td colspan="1" class="vrule right">  16.10. </td> <td colspan="1" class="right">  18.10. </td> <td colspan="1" class="right">  20.10. </td></tr>
<tr><td colspan="1" class="center hrule">    2 </td> <td colspan="1" class="vrule center hrule">     1 </td> <td colspan="1" class="vrule right hrule">  23.10. </td> <td colspan="1" class="right hrule">  25.10. </td> <td colspan="1" class="right hrule">  27.10. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     2 </td> <td colspan="1" class="vrule right">  30.10. </td> <td colspan="1" class="right">   1.11. </td> <td colspan="1" class="right">   3.11. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     3 </td> <td colspan="1" class="vrule right">   6.11. </td> <td colspan="1" class="right">   8.11. </td> <td colspan="1" class="right">  10.11. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     4 </td> <td colspan="1" class="vrule right">  13.11. </td> <td colspan="1" class="right">  15.11. </td> <td colspan="1" class="right">  17.11. </td></tr>
<tr><td colspan="1" class="center hrule">    3 </td> <td colspan="1" class="vrule center hrule">     1 </td> <td colspan="1" class="vrule right hrule">  20.11. </td> <td colspan="1" class="right hrule">  22.11. </td> <td colspan="1" class="right hrule">  24.11. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     2 </td> <td colspan="1" class="vrule right">  27.11. </td> <td colspan="1" class="right">  29.11. </td> <td colspan="1" class="right">   1.12. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     3 </td> <td colspan="1" class="vrule right">   4.12. </td> <td colspan="1" class="right">   6.12. </td> <td colspan="1" class="right">   8.12. </td></tr>
<tr><td colspan="1" class="center">      </td> <td colspan="1" class="vrule center">     4 </td> <td colspan="1" class="vrule right">  11.12. </td> <td colspan="1" class="right">  13.12. </td> <td colspan="1" class="right">  15.12. </td></tr></table>
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Odevzdávání"><h3>A.5.1 Odevzdávání </h3></a> <div class="par">Součástí každého zadání je jeden zdrojový soubor (kostra), do
kterého své řešení vepíšete. Vypracované příklady lze pak odevzdávat
stejně jako přípravy:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>do <em>odevzdávárny</em> s názvem <code>sN_úkol</code> v ISu (např. <code>s1_a_queens</code>),
</li><li>příkazem <code>pb152 submit sN_úkol</code> ve složce <code>~/pb152/sN</code>, např.
<code>pb152 submit s1_a_queens</code>.
</li></ol>
Podrobnější instrukce naleznete opět v kapitole T.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Vyhodnocení"><h3>A.5.2 Vyhodnocení </h3></a> <div class="par">Vyhodnocení Vašich řešení probíhá ve třech fázích, a s každou z nich
je spjata sada automatických testů. Tyto sady jsou:
<!-- paragraph -->
</div>
<div class="par"><ul><li>„syntax“ – kontroluje, že odevzdaný program je syntakticky
správně, lze jej přeložit a prochází základními statickými
kontrolami,
</li><li>„sanity“ – kontroluje, že odevzdaný program se chová „rozumně“ na
jednoduchých případech vstupu; tyto testy jsou rozsahem a stylem
podobné těm, které máte přiložené k příkladům ve cvičení,
</li><li>„verity“ – důkladně kontrolují správnost řešení, včetně složitých
vstupů a okrajových případů a kontroly paměťových chyb.
</li></ul>
Fáze na sebe navazují v tom smyslu, že nesplníte-li testy v některé
fázi, žádná další se už (pro dané odevzdání) nespustí. Pro splnění
domácí úlohy je klíčová fáze „verity“, za kterou jsou Vám uděleny
body. Časový plán vyhodnocení fází je následovný:
<!-- paragraph -->
</div>
<div class="par"><ul><li>kontrola „syntax“ se provede obratem (do cca 5 minut od
odevzdání),
</li><li>kontrola „sanity“ každých 6 hodin počínaje půlnocí (tzn. 0:00,
6:00, 12:00, 18:00),
</li><li>kontrola „verity“ se provede v pondělí, středu a pátek ve 23:59
(dle tabulky uvedené výše).
</li></ul>
Vyhodnoceno je vždy pouze nejnovější odevzdání, a každé odevzdání je
vyhodnoceno v každé fázi nejvýše jednou. Výsledky naleznete
v poznámkových blocích v ISu (každá úloha v samostatném bloku),
případně je získáte příkazem <code>pb152 status</code>.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Bodování"><h3>A.5.3 Bodování </h3></a> <div class="par">Za každý domácí úkol, ve kterém Vaše odevzdání v příslušném termínu
splní testy „verity“, získáte 10 bodů.
<!-- paragraph -->
</div>
<div class="par">Za stejný úkol máte dále možnost získat body za kvalitu kódu, a to
vždy v hodnotě max. 5 bodů. Body za kvalitu se počítají v bloku, <em>ve
kterém byly uděleny</em>, tzn. body za kvalitu ze <em>sady 1</em> se započtou
do <em>bloku 2</em>.
<!-- paragraph -->
</div>
<div class="par">Maximální bodový zisk za jednotlivé sady:
<!-- paragraph -->
</div>
<div class="par"><ul><li>sada 1: 60 za funkčnost v bloku 1 + 30 za kvalitu v bloku 2,
</li><li>sada 2: 60 za funkčnost v bloku 2 + 30 za kvalitu v bloku 3,
</li><li>sada 3: 60 za funkčnost v bloku 3 + 30 za kvalitu v bloku 4
(<em>zkouškovém</em>).
</li></ul>
<!-- paragraph -->
</div>
<a name="Pravidla a organizace/Hodnocení kvality kódu"><h3>A.5.4 Hodnocení kvality kódu</h3></a> <div class="par">Automatické testy ověřují <em>správnost</em> vašich programů (do takové
míry, jak je to praktické – ani nejpřísnější testy nemůžou zaručit,
že máte program zcela správně). Správnost ale není jediné kritérium,
podle kterého lze programy hodnotit: podobně důležité je, aby byl
program <em>čitelný</em>. Programy totiž mimo jiné slouží ke komunikaci
myšlenek lidem – dobře napsaný a správně okomentovaný kód by měl
čtenáři sdělit, jaký řeší problém, jak toto řešení funguje a
u obojího objasnit <em>proč</em>.
<!-- paragraph -->
</div>
<div class="par">Je Vám asi jasné, že čitelnost programu člověkem může hodnotit pouze
člověk: proto si každý Váš <em>úspěšně</em> vyřešený domácí úkol přečte
opravující a své postřehy Vám sdělí. Přitom zároveň Váš kód
oznámkuje podle kritérií podrobněji rozepsaných v kapitole Z.
Tato kritéria aplikujeme při známkování takto:
<!-- paragraph -->
</div>
<div class="par"><ul><li>hodnocení A dostane takové řešení, které jasně popisuje řešení
zadaného problému, je správně dekomponované na podproblémy, je
zapsáno bez zbytečného opakování, a používá správné abstrakce,
algoritmy a datové struktury,

</li><li>hodnocení B dostane program, který má výrazné nedostatky v jedné,
nebo nezanedbatelné nedostatky ve dvou oblastech výše zmíněných,
například:

<ul><li>je relativně dobře dekomponovaný a zbytečně se neopakuje, ale
používá nevhodný algoritmus nebo datovou strukturu a není
zapsán příliš přehledně,
</li></ul>
<ul><li>používá optimální algoritmus a datové struktury a je dobře
dekomponovaný, ale lokálně opakuje tentýž kód s drobnými
obměnami, a občas používá zavádějící nebo jinak nevhodná
jména podprogramů, proměnných atp.,
</li></ul>
<ul><li>jinak dobrý program, který používá zcela nevhodný
algoritmus, <em>nebo</em> velmi špatně pojmenované proměnné, <em>nebo</em> je
zapsaný na dvě obrazovky úplně bez dekompozice,
</li></ul>
</li><li>hodnocení X dostanou programy, u kterých jste se dobrovolně
vzdali hodnocení (a to jasně formulovaným komentářem <em>na začátku
souboru</em>, např. „Vzdávám se hodnocení.“),

</li><li>hodnocení C dostanou všechny ostatní programy, zejména ty, které
kombinují dvě a více výrazné chyby zmiňované výše.
</li></ul>
Známky Vám budou zapsány druhé úterý následujícího bloku.
Dostanete-li známku B nebo C, budete mít možnost svoje řešení
ještě zlepšit, odevzdat znovu, a známku si tak opravit:
<!-- paragraph -->
</div>
<div class="par"><ul><li>na opravu budete mít týden,
</li><li>na opraveném programu nesmí selhat verity testy,
</li><li>testy budou nadále probíhat se stejnou kadencí jako během řádné
doby k vypracování (pondělí, středa, pátek o 23:59).
</li></ul>
Bude-li opravující s vylepšeným programem spokojen, výslednou známku
Vám upraví.
<!-- paragraph -->
</div>
<div class="par"><table class="">
<tr><td colspan="1" class="center"> sada </td> <td colspan="1" class="vrule right"> řádný termín </td> <td colspan="1" class="vrule right"> známka </td> <td colspan="1" class="vrule right"> opravný termín </td> <td colspan="1" class="vrule right"> známka </td></tr>
<tr><td colspan="1" class="center hrule">    1 </td> <td colspan="1" class="vrule right hrule">     <em>20.10.</em> </td> <td colspan="1" class="vrule right hrule"> 31.10. </td> <td colspan="1" class="vrule right hrule">        <em>7.11.</em> </td> <td colspan="1" class="vrule right hrule"> 14.11. </td></tr>
<tr><td colspan="1" class="center">    2 </td> <td colspan="1" class="vrule right">     <em>17.11.</em> </td> <td colspan="1" class="vrule right"> 28.11. </td> <td colspan="1" class="vrule right">        <em>5.12.</em> </td> <td colspan="1" class="vrule right"> 12.12. </td></tr>
<tr><td colspan="1" class="center">    3 </td> <td colspan="1" class="vrule right">     <em>15.12.</em> </td> <td colspan="1" class="vrule right">   2.1. </td> <td colspan="1" class="vrule right">         <em>9.1.</em> </td> <td colspan="1" class="vrule right">  16.1. </td></tr></table>
<!-- paragraph -->
</div>
<div class="par">Jednotlivé <em>výsledné</em> známky se promítnou do bodového hodnocení
úkolu následovně:
<!-- paragraph -->
</div>
<div class="par"><ul><li>známka <em>A</em> Vám vynese <em>5 bodů</em>,
</li><li>známka <em>B</em> pak <em>2 body</em>,
</li><li>známka <em>X</em> žádné body neskýtá,
</li><li>známka <em>C</em> je hodnocena <em>-1 bodem</em>.
</li></ul>
Samotné body za funkcionalitu se při opravě kvality již nijak
nemění.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Neúspěšná řešení"><h3>A.5.5 Neúspěšná řešení</h3></a> <div class="par">Příklady, které se Vám nepodaří vyřešit kompletně (tzn. tak, aby na
nich uspěla kontrola „verity“) nebudeme hodnotit. Nicméně může
nastat situace, kdy byste potřebovali na „téměř hotové“ řešení
zpětnou vazbu, např. proto, že se Vám nepodařilo zjistit, proč
nefunguje.
<!-- paragraph -->
</div>
<div class="par">Taková řešení můžou být předmětem společné analýzy ve cvičení,
v podobném duchu jako probíhá rozprava kolem odevzdaných příprav
(samozřejmě až poté, co pro danou sadu skončí odevzdávání). Máte-li
zájem takto rozebrat své řešení, domluvte se, ideálně s předstihem,
se svým cvičícím. To, že jste autorem, zůstává mezi cvičícím a Vámi
– Vaši spolužáci to nemusí vědět (ke kódu se samozřejmě můžete
v rámci debaty přihlásit, uznáte-li to za vhodné). Stejná pravidla
platí také pro nedořešené přípravy (musíte je ale odevzdat).
<!-- paragraph -->
</div>
<div class="par">Tento mechanismus je omezen prostorem ve cvičení – nemůžeme zaručit,
že v případě velkého zájmu dojde na všechny (v takovém případě
cvičící vybere ta řešení, která bude považovat za přínosnější pro
skupinu – je tedy možné, že i když se na Vaše konkrétní řešení
nedostane, budete ve cvičení analyzovat podobný problém v řešení
někoho jiného).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Vzájemné recenze"><h2>A.6 Vzájemné recenze</h2></a> <div class="par">Jednou z možností, jak získat body za aktivitu, jsou vzájemné (peer)
recenze. Smyslem této aktivity je získat praxi ve čtení a hodnocení
cizího kódu. Možnost psát tyto recenze se váže na vlastní úspěšné
vypracování téhož příkladu.
<!-- paragraph -->
</div>
<div class="par">Příklad: odevzdáte-li ve druhém týdnu 4 přípravy, z toho u třech
splníte testy „verity“ (řekněme <code>p1</code>, <code>p2</code>, <code>p5</code>), ve třetím týdnu
dostanete po jednom řešení těchto příkladů (tzn. budete mít možnost
recenzovat po jedné instanci <code>02/p1</code>, <code>02/p2</code> a <code>02/p5</code>). Termín pro
odevzdání recenzí na přípravy z druhé kapitoly je shodný s termínem
pro odevzdání příprav třetí kapitoly (tzn. sobotní půlnoc).
<!-- paragraph -->
</div>
<div class="par">Vypracování těchto recenzí je dobrovolné. Za každou vypracovanou
recenzi získáte jeden bod za aktivitu, počítaný v týdnu, kdy jste
recenze psali (v uvedeném příkladu by to tedy bylo ve třetím týdnu
semestru, tedy do stejné „kolonky“ jako body za příklady <code>02/r</code>).
<!-- paragraph -->
</div>
<div class="par">Udělení bodů je podmíněno smysluplným obsahem – <em>nestačí</em> napsat
„nemám co dodat“ nebo „není zde co komentovat“. Je-li řešení dobré,
napište <em>proč</em> je dobré (viz též níže). Vámi odevzdané recenze si
přečte Váš cvičící a některé z nich může vybrat k diskusi ve cvičení
(v dalším týdnu), v podobném duchu jako přípravy samotné.
<!-- paragraph -->
</div>
<em><div class="par">Pozor</em>, v jednom týdnu lze získat maximálně <em>3 body</em> za aktivitu,
bez ohledu na jejich zdroj (recenze, vypracování příkladu u tabule,
atp.). Toto omezení není dotčeno ani v případě, kdy dostanete
k vypracování více než 3 příklady (můžete si ale vybrat, které
z nich chcete recenzovat).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Jak recenze psát"><h3>A.6.1 Jak recenze psát</h3></a> <div class="par">Jak recenze vyzvednout a odevzdat je blíže popsáno v kapitole T.
Své komentáře vkládejte přímo do vyzvednutých zdrojových souborů.
Komentáře můžete psát česky (slovensky) nebo anglicky, volba je na
Vás. Komentáře by měly být stručné, ale užitečné – Vaším hlavním
cílem by mělo být pomoct adresátovi naučit se lépe programovat.
<!-- paragraph -->
</div>
<div class="par">Snažte se aplikovat kritéria a doporučení z předchozí sekce (nejlépe
na ně přímo odkázat, např. „tuto proměnnou by šlo jistě pojmenovat
lépe (viz doporučení 2.b)“). Nebojte se ani vyzvednout pozitiva
(můžete zde také odkázat doporučení, máte-li například za to, že je
obzvlášť pěkně uplatněné) nebo poznamenat, když jste se při čtení
kódu sami něco naučili.
<!-- paragraph -->
</div>
<div class="par">Komentáře vkládejte vždy <em>před</em> komentovaný celek, a držte se podle
možnosti tohoto vzoru (použití <code>**</code> pomáhá odlišit původní komentáře
autora od poznámek recenzenta):
<!-- paragraph -->
</div>
<pre><code class="plain">/** A short, one-line remark. **/
</code></pre>
<div class="par">
U víceřádkových komentářů:
<!-- paragraph -->
</div>
<pre><code class="plain">/** A longer comment, which should be wrapped to 80 columns or
 ** less, and where each line should start with the ** marker.
 ** It is okay to end the comment on the last line of text like
 ** this. **/
</code></pre>
<div class="par">
Při vkládání komentářů <em>neměňte</em> existující řádky (zejména se
ujistěte, že máte vypnuté automatické formátování, editujete-li
zdrojový kód v nějakém IDE). Jediné povolená operace jsou:
<!-- paragraph -->
</div>
<div class="par"><ul><li>vložení nových řádků (prázdných nebo s komentářem), nebo
</li><li>doplnění komentáře na stávající <em>prázdný</em> řádek.
</li></ul>
<!-- paragraph -->
</div>
<a name="Pravidla a organizace/Závěrečný programovací test"><h2>A.7 Závěrečný programovací test</h2></a> <div class="par">Zkouškové období tvoří pomyslný 4. blok a platí zde stejné kritérium
jako pro všechny ostatní bloky: musíte získat alespoň 60 bodů.
Závěrečný test:
<!-- paragraph -->
</div>
<div class="par"><ul><li>proběhne v počítačové učebně bez přístupu k internetu nebo
vlastním materiálům,
</li><li>k dispozici bude tato sbírka (bez vzorových řešení příkladů typu
<code>e</code> a <code>r</code>), skripta PB152 a manuálové stránky (příkaz <code>man</code>),
</li><li>budete moct používat textový editor nebo vývojové prostředí VS
Code, překladač jazyka C (<code>gcc</code> a/nebo <code>clang</code>) a nástroje
<code>valgrind</code> a <code>gdb</code>.
</li></ul>
Na vypracování praktické části budete mít 4 hodiny čistého času, a
bude sestávat ze šesti příkladů, které budou hodnoceny automatickými
testy, s maximálním ziskem 90 bodů. Příklady jsou hodnoceny binárně
(tzn. příklad je uznán za plný počet bodů, nebo uznán není). Kvalita
kódu hodnocena nebude. Příklady budou na stejné úrovni obtížnosti
jako příklady typu <code>p</code>/<code>r</code>/<code>v</code> ze sbírky.
<!-- paragraph -->
</div>
<div class="par">Během zkoušky můžete kdykoliv odevzdat (na počet odevzdání není
žádný konkrétní limit) a vždy dostanete zpět výsledek testů syntaxe
a sanity. Součástí zadání bude navíc soubor <code>tokens.txt</code>, kde
naleznete 4 kódy. Každý z nich lze použít nejvýše jednou (vložením
do komentáře do jednoho z příkladů), a každé použití kódu odhalí
výsledek verity testu pro ten soubor, do kterého byl vložen. Toto se
projeví pouze při prvním odevzdání s vloženým kódem, v dalších
odevzdáních bude tento kód ignorován (bez ohledu na soubor, do
kterého bude vložen).
<!-- paragraph -->
</div>
<div class="par">Zkouška proběhne až po vyhodnocení recenzí za třetí blok (tzn. ve
druhé polovině zkouškového období). Plánované termíny<a class="anchor" id="foothead5" href="#footnote5"><sup>5</sup></a> jsou tyto:
<!-- paragraph -->
</div>
<div class="par"><ul><li>středa 24.1. 9:00–13:00, 14:00–18:00,
</li><li>středa 31.1. 9:00–13:00, 14:00–18:00,
</li><li>středa  7.2. 9:00–13:00, 14:00–18:00,
</li><li>středa 14.2. 9:00–13:00, 14:00–18:00.
</li></ul>
<!-- paragraph -->
</div>
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote5" href="#foothead5"><sup>5</sup></a><div class="par"> Může se stát, že termíny budeme z technických nebo organizačních  důvodů posunout na jiný den nebo hodinu. V takovém případě Vám  samozřejmě změnu s dostatečným předstihem oznámíme.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Pravidla a organizace/Vnitrosemestrálky"><h3>A.7.1 Vnitrosemestrálky </h3></a> <div class="par">V posledním týdnu každého bloku, tedy
<!-- paragraph -->
</div>
<div class="par"><ul><li>týden 4 (16.-20. října),
</li><li>týdnu 8 (13.–17. listopadu),
</li><li>týden 12 (11.-15. prosince),
</li></ul>
proběhne v rámci cvičení programovací test na 40 minut. Tyto testy
budou probíhat za stejných podmínek, jako výše popsaný závěrečný
test (slouží tedy mimo jiné jako příprava na něj). Řešit budete vždy
ale pouze jeden příklad, za který můžete získat 3 body, které se
počítají jako body za aktivitu v tomto cvičení.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Pravidla a organizace/Opisování"><h2>A.8 Opisování </h2></a> <div class="par">Na všech zadaných problémech pracujte prosím zcela samostatně – toto
se týká jak příkladů ze sbírky, které budete odevzdávat, tak
domácích úloh ze sad. To samozřejmě neznamená, že Vám zakazujeme
společně studovat a vzájemně si pomáhat látku pochopit: k tomuto
účelu můžete využít všechny zbývající příklady ve sbírce (tedy ty,
které nebude ani jeden z Vás odevzdávat), a samozřejmě nepřeberné
množství příkladů a cvičení, které jsou k dispozici online.
<!-- paragraph -->
</div>
<div class="par">Příklady, které odevzdáváte, slouží ke kontrole, že látce skutečně
rozumíte, a že dokážete nastudované principy prakticky aplikovat.
Tato kontrola je pro Váš pokrok naprosto klíčová – je velice snadné
získat pasivním studiem (čtením, posloucháním přednášek, studiem již
vypracovaných příkladů) pocit, že něčemu rozumíte. Dokud ale sami
nenapíšete na dané téma několik programů, jedná se pravděpodobně
skutečně pouze o pocit.
<!-- paragraph -->
</div>
<div class="par">Abyste nebyli ve zbytečném pokušení kontroly obcházet, nedovolenou
spolupráci budeme relativně přísně trestat. Za každý prohřešek Vám
bude strženo <em>v každé instanci</em> (jeden týden příprav se počítá jako
jedna instance, příklady ze sad se počítají každý samostatně):
<!-- paragraph -->
</div>
<div class="par"><ul><li>1/2 bodů získaných (ze všech příprav v dotčeném týdnu, nebo za
jednotlivý příklad ze sady),
</li><li>10 bodů z hodnocení bloku, do kterého opsaný příklad patří,
</li><li>10 bodů (navíc k předchozím 10) z celkového hodnocení.
</li></ul>
Opíšete-li tedy například 2 přípravy ve druhém týdnu a:
<!-- paragraph -->
</div>
<div class="par"><ul><li>Váš celkový zisk za přípravy v tomto týdnu je 4,5 bodu,
</li><li>Váš celkový zisk za první blok je 65 bodů,
</li></ul>
jste <em>automaticky hodnoceni známkou X</em> (65 - 2,25 - 10 je méně než
potřebných 60 bodů). Podobně s příkladem z první sady (65 - 5 - 10),
atd. Máte-li v bloku bodů dostatek (např. 80 - 5 - 10 &gt; 60), ve
studiu předmětu pokračujete, ale započte se Vám ještě navíc
penalizace 10 bodů do celkové známky. Přestává pro Vás proto platit
pravidlo, že 4 splněné bloky jsou automaticky E nebo lepší.
<!-- paragraph -->
</div>
<div class="par">V situaci, kdy:
<!-- paragraph -->
</div>
<div class="par"><ul><li>za bloky máte před penalizací 77, 62, 61, 64,
</li><li>v prvním bloku jste opsali domácí úkol,
</li></ul>
budete penalizováni:
<!-- paragraph -->
</div>
<div class="par"><ul><li>v prvním bloku 10 + 5, tzn. bodové zisky za bloky budou efektivně
62, 62, 61, 64,
</li><li>v celkovém hodnocení 10, tzn. celkový zisk 62 + 62 + 61 + 64 - 10
= 239, a budete tedy hodnoceni známkou <em>F</em>.
</li></ul>
To, jestli jste příklad řešili společně, nebo jej někdo vyřešil
samostatně, a poté poskytl své řešení někomu dalšímu, není pro účely
kontroly opisování důležité. Všechny „verze“ řešení odvozené ze
společného základu budou penalizovány stejně. Taktéž <em>zveřejnění
řešení</em> budeme chápat jako pokus o podvod, a budeme jej trestat, bez
ohledu na to, jestli někdo stejné řešení odevzdá, nebo nikoliv.
<!-- paragraph -->
</div>
<div class="par">Podotýkáme ještě, že kontrola opisování <em>nespadá</em> do desetidenní
lhůty pro hodnocení průběžných kontrol. Budeme se sice snažit
opisování kontrolovat co nejdříve, ale odevzdáte-li opsaný příklad,
můžete být bodově penalizováni kdykoliv (tedy i dodatečně, a to až
do konce zkouškového období).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Úvod"><h1>B Úvod</h1></a> <div class="par">Tato kapitola je předmětem cvičení v prvním týdnu semestru. V tomto
cvičení se seznámíte s organizací cvičení, se studijními materiály
(tedy zejména touto sbírkou) a také si připomenete základy práce
v prostředí POSIX a v jazyce C. Detailněji se pak budeme zabývat
základní strukturou příkladů (definice, hlavičkové soubory,
procedura <code>main</code>, pomocné testovací funkce, atp.), vztahem tohoto
předmětu ke standardu POSIX a v neposlední řadě obecnými principy
ošetření různých chybových stavů v programech.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Úvod/Normy"><h2>B.1 Normy </h2></a> <div class="par">Kurz je celý veden v programovacím jazyce C99, specifikovaném normou
ISO. Krom samotného jazyka C budeme používat rozhraní operačního
systému v podobě, kterou specifikuje norma POSIX, a několik málo
vybraných rozšíření (zejména právě v souvislosti s ošetřením chyb –
drobné odchýlení od standardu nám totiž ušetří značné množství
psaní).
<!-- paragraph -->
</div>
<div class="par">Není-li daná konstrukce nebo knihovní funkce specifikována normou
<em><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">ISO 9899:1999</a></em> (ISO C99; <em><a href="http://port70.net/~nsz/c/c99/n1256.html">HTML verze</a></em>), normou
<em><a href="https://pubs.opengroup.org/onlinepubs/9699919799/">IEEE Std 1003.1-2017</a></em> (POSIX), ani explicitně zmíněna v této
sbírce jako podporovaná nad rámec těchto standardů, <em>nepoužívejte
ji</em>. Řešení, která na takové konstrukce spoléhají, se nemusí po
odevzdání přeložit, nebo se v horším případě mohou chovat jinak, než
na Vašem systému (nebo i jinak, než na serveru <code>aisa</code>). Nevíte-li
jistě, zda je v tomto směru Vaše řešení v pořádku, odevzdávejte vždy
s dostatečným předstihem.
<!-- paragraph -->
</div>
<div class="par">Nevíte-li, je-li nějaká funkcionalita, kterou byste chtěli použít,
součástí zmiňovaných standardů, a jejich čtení je nad Vaše síly,
zeptejte se v diskusním fóru, nebo na cvičení. Řešení příkladů
z této sbírky nebude nikdy vyžadovat funkce, konstrukce, atp., které
se neobjevují ani v ukázkách, ani v úvodech kapitol, ani nejsou
explicitně zmíněné v zadání daného příkladu.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Úvod/Manuálové stránky"><h2>B.2 Manuálové stránky</h2></a> <div class="par">Každá knihovní funkce z norem POSIX a ISO C99 je zdokumentovaná
systémem <code>man</code>, který je nainstalovaný na většině
POSIX-kompatibilních systémů (server <code>aisa</code> nevyjímaje). Příkaz
<code>man</code> lze použít těmito způsoby:
<!-- paragraph -->
</div>
<div class="par"><ul><li><code>man 2 read</code> zobrazí dokumentaci <em>lokální</em> verze systémového
volání <code>read</code> (za <code>read</code> lze dosadit libovolné systémové volání)
– pozor, tato lokální verze může mít oproti POSIX-u
nepřenositelná rozšíření (většinou Vás na to ale manuálová
stránka explicitně upozorní),
</li><li><code>man 3 dprintf</code> zobrazí dokumentaci <em>lokální</em> verze knihovní
funkce <code>dprintf</code> (opět lze dosadit libovolnou jinou knihovní
funkci, např.  <code>memcmp</code>),
</li><li><code>man 3p read</code> zobrazí příslušnou část normy POSIX<a class="anchor" id="foothead6" href="#footnote6"><sup>6</sup></a> – na zde
popsané chování se můžete spolehnout.
</li></ul>
Samozřejmě krom příkazu <code>man</code> můžete použít výše odkazované normy
samotné. Dalším poměrně spolehlivým zdrojem informací o jazyku C je
online referenční příručka <em><a href="https://en.cppreference.com/w/c">cppreference</a></em>.
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote6" href="#foothead6"><sup>6</sup></a><div class="par"> Norma POSIX zahrnuje jako svou část popis knihovních funkcí  specifikovaných normou ISO <em>C89</em> (nikoliv novější <em>C99</em> která je  závazná pro tento kurz). Autorům této sbírky není známo, že by  mezi těmito normami existoval (v částech sdílených s normou POSIX)  pro tento předmět relevantní konflikt. Můžete se tedy odvolávat na  normu POSIX i u funkcí, které patří do průniku s ISO C.  Narazíte-li ovšem při studiu literatury na nějaké relevantní  rozdíly, budeme rádi, když se s námi o tento nález podělíte  v diskusním fóru.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Úvod/Struktura programu"><h2>B.3 Struktura programu</h2></a> <div class="par">Každý příklad, který budete v tomto předmětu řešit, je tvořen jedním
zdrojovým souborem v jazyce C. Součástí kostry je text zadání,
případný pomocný kód, který by Vám měl řešení ulehčit, procedura
<code>main</code>, která obsahuje základní sadu testů a případné pomocné
testovací funkce. Vaším úkolem je do této kostry doplnit kód tak,
aby výsledný celek splňoval text zadání. Hlavním úkolem přiložených
testů je usnadnit Vám dosažení tohoto cíle. O hlavních částech
programu se více dovíte v ukázkách a samotných příkladech.
<!-- paragraph -->
</div>
<div class="par">Programy, které budete psát budou dvou hlavních typů – může se
jednat o znovupoužitelné („knihovní“) funkce se zadaným rozhraním,
nebo o de-facto kompletní programy. Z povahy zadaného programu bude
obvykle zřejmé, o který typ úlohy se jedná (je-li např. vstupem
popisovač otevřeného souboru, nebo nějaká datová struktura, těžko se
může jednat o kompletní program).
<!-- paragraph -->
</div>
<div class="par">Trochu atypicky, i v případech, kdy píšete de-facto kompletní
program, vstupní bod tohoto programu bude nějaká námi zadaná
procedura (např. v přípravě <code>02/p1_echoc</code> to je procedura s názvem
<code>echoc</code>), nikoliv speciální procedura <code>main</code>.
<!-- paragraph -->
</div>
<div class="par">Tuto formu jsme zvolili zejména pro jednoduchost testování – dodané
testy vytvoří pro Váš program nový proces (použitím systémového
volání <code>fork</code>) a chování tohoto programu pak vyhodnotí „zvenčí“
z rodičovského procesu. Vám tím zejména odpadne nutnost spouštět
různé pomocné skripty, které by hotový program testovaly, nebo
provádět testovací scénáře „ručně“. Spuštěním přeloženého programu
bez parametrů se tento přímo otestuje.
<!-- paragraph -->
</div>
<div class="par">U tohoto typu programů ale dodaná procedura <code>main</code> umožní i jejich
přímé spuštění, pro případy, kdy si je budete chtít vyzkoušet
obvyklým způsobem (jak tohoto dosáhnout zjistíte v komentáři na
začátku dodané procedury <code>main</code>).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Úvod/Ošetření chyb"><h2>B.4 Ošetření chyb</h2></a> <div class="par">Od typu programu nebo podprogramu se bude typicky odvíjet i způsob,
jakým se vypořádáme s chybovými stavy. Základní pravidlo systémového
programování je, že <em>každé systémové volání může selhat</em> a totéž
platí pro každý podprogram (ať už knihovní nebo Váš vlastní), který
vnitřně nějaké systémové volání používá (ať už přímo, nebo nepřímo).
<!-- paragraph -->
</div>
<div class="par">Chyby obecně dělíme na <em>fatální</em> a <em>opravitelné</em>. Toto dělení je
ovšem silně kontextově závislé – tatáž chyba může být v některých
případech fatální, ale v jiných opravitelná. Fatální chyba je
taková, po které nemá smysl pokračovat ve vykonávání programu a
tento je lepší rovnou ukončit. Je samozřejmě žádoucí uživateli tuto
chybu ještě před ukončením programu co nejpřesněji popsat.
Opravitelné chyby jsou pak takové, kdy může program ve své činnosti
pokračovat.
<!-- paragraph -->
</div>
<div class="par">Zde do hry vstupuje onen rozdíl mezi kompletním programem a neúplným
(znovupoužitelným) podprogramem. Máme-li pod kontrolou celý program,
máme automaticky k dispozici mnohem přesnější informaci o tom,
v jakém kontextu daná chyba nastala, a můžeme se k ní tedy mnohem
snadněji postavit jako k chybě fatální.
<!-- paragraph -->
</div>
<div class="par">Ve znovupoužitelném podprogramu je situace komplikovanější –
ukončíme-li při nějaké chybě celý program, omezíme tím možnosti
použití tohoto podprogramu v situaci, kdy je tato reakce nežádoucí.
Na druhé straně správně se vypořádat s opravitelnou chybou je mnohem
náročnější – program jako celek se musí z chyby zotavit. Dotčený
podprogram obvykle nemůže svůj úkol úspěšně dokončit; musí ale:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>vrátit jakékoliv už provedené efekty, které by mohly mít
negativní dopad na další fungování programu – zejména musí
uvolnit veškeré již alokované zdroje a zajistit platnost
relevantních invariantů,
</li><li>chybu ohlásit volajícímu podprogramu – nikoliv přímo uživateli –
způsobem, který umožní zbytku programu na chybu vhodně reagovat.
</li></ol>
Při dekompozici programu na podprogramy musíme vždy zvážit, které
chyby považovat za fatální a které nikoliv. Od tohoto rozhodnutí se
pak odvíjí jak jednoduchost zápisu (považovat chybu za fatální je
jednodušší) tak i praktická znovupoužitelnost navrženého podprogramu
(podprogram, který při sebemenším problému ukončí program, není
příliš znovupoužitelný).
<!-- paragraph -->
</div>
<!-- paragraph -->
<!-- paragraph -->
<a name="Úvod/Demonstrace (ukázky)"><h2>B.d Demonstrace (ukázky)</h2></a> <!-- paragraph -->
<a name="Úvod/[‹empty›]"><h3>B.d.1 [<code>empty</code>]</h3></a> <div class="par">Tento program nic nedělá, slouží pouze jako ukázka základní
struktury. Ve všech programech v tomto předmětu budeme
deklarovat, že jsou napsané s ohledem na normu POSIX.1–2017.
K tomu slouží následovná direktiva preprocesoru: 
<!-- paragraph -->
</div>
<pre><code class="cxx">#define _POSIX_C_SOURCE 200809L 
</code></pre>
<div class="par">
Relevantní informace z kapitoly 2 standardu POSIX:
<!-- paragraph -->
</div>
<blockquote>
<div class="par">A POSIX-conforming application shall ensure that the feature
test macro _POSIX_C_SOURCE is defined before inclusion of any
header.
<!-- paragraph -->
</div>
<div class="par">When an application includes a header described by
POSIX.1-2017, and when this feature test macro is defined to
have the value <code>200809L</code>: All symbols required by POSIX.1-2017
to appear when the header is included shall be made visible.
</blockquote>
<!-- paragraph -->
</div>
<div class="par">Výše uvedená direktiva <code>#define</code> není jediný způsob, jak tomuto
požadavku dostát, ale je pro naše účely nejjednodušší. Musí vždy
stát před jakoukoliv direktivou <code>#include</code>. 
<!-- paragraph -->
</div>
<div class="par">Obvykle následují direktivy <code>#include</code>, které odkazují tzv.
systémové hlavičkové soubory. V těchto souborech jsou deklarovány
podprogramy, které poskytuje implementace jazyka C a operační
systém. Které hlavičkové soubory je pro použití daného
podprogramu vložit je vždy popsáno v odpovídající manuálové
stránce (a také v příslušných normách). V ukázkách a kostrách
budeme u každého <code>#include</code> v komentáři uvádět podprogramy,
případně konstanty, které z dané hlavičky hodláme využívat. 
<!-- paragraph -->
</div>
<pre><code class="cxx">#include &lt;stdlib.h&gt;     /* exit */ 
</code></pre>
<div class="par">
Na tomto místě bude ve většině příkladů popsaný podprogram,
napsání kterého je Vaším úkolem. V této ukázce zde není nic. 
<!-- paragraph -->
</div>
<div class="par">Konečně bude součástí kostry procedura <code>main</code>, která představuje
vstupní bod výsledného programu. Jejím obvyklým úkolem bude
otestovat podprogram, který jste výše naprogramovali. V této
ukázce nedělá nic, pouze explicitně ukončí program. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int main() /* demo */ 
{
</code></pre>
<div class="par">Procedura <code>exit</code> ukončí vykonávání programu. Má stejný efekt,
jako návrat z procedury <code>main</code>, ale lze ji použít na
libovolném místě. V tomto kurzu ji prakticky nikdy nebudete
mít důvod použít (může se ale objevit v testech, proto je
dobré ji znát). 
<!-- paragraph -->
</div>
<pre><code class="cxx">    exit( 0 ); 
}
</code></pre>
<div class="par">

<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Úvod/[‹strings›]"><h3>B.d.2 [<code>strings</code>]</h3></a> <div class="par">Operační systém a také většina programů při své činnosti
komunikuje s uživatelem. Tato komunikace je obvykle postavena na
textu, a proto musí mít program a operační systém společný
způsob, kterým text reprezentuje v paměti. I kdybychom si
odmysleli klasické výpisy na obrazovku, tak základní věc jako
soubor má <em>jméno</em>, které je samozřejmě také kusem textu.
<!-- paragraph -->
</div>
<div class="par">Normy ISO C a POSIX specifikují některé základní charakteristiky
kódování textu:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>každé písmeno<a class="anchor" id="foothead7" href="#footnote7"><sup>7</sup></a> je kódováno nějakou posloupností bajtů, a
fragment textu (tzv. <em>řetězec</em>) je v paměti uložen tak, že
kódování jednotlivých znaků (písmen) jsou uložena za sebou
(na postupně se zvyšujících adresách),
</li><li>nulový bajt je vyhrazen pro speciální účely (pro řadu
knihovních a systémových funkcí označuje konec řetězce, tzn.
bajt uložený bezprostředně před nulovým bajtem je poslední
bajt kódující daný řetězec),
</li><li>vybranou množinu znaků, nazývanou Portable Character Set,
musí být systém schopen kódovat, a to navíc tak, že každému
znaku odpovídá jeden bajt (jedná se o většinu znaků
obsažených v ASCII<a class="anchor" id="foothead8" href="#footnote8"><sup>8</sup></a>),
</li><li>konkrétní číselné hodnoty, kterými jsou tyto znaky kódované,
nejsou pevně určeny (s výjimkou nulového znaku, který musí
být kódován nulovým bajtem), ale v praxi každý systém, který
potkáte, bude používat kódování ASCII, a naprostá většina
UTF-8 (které je nadmnožinou ASCII). 
</li></ol>
<pre><code class="cxx">#define _POSIX_C_SOURCE 200809L 
#include &lt;string.h&gt;     /* strlen, strcmp */
#include &lt;stdio.h&gt;      /* dprintf, snprintf */
#include &lt;unistd.h&gt;     /* STDOUT_FILENO */
#include &lt;assert.h&gt;
</code></pre>

<pre><code class="cxx">int main( void ) /* demo */ 
{
</code></pre>
Nejjednodušší způsob, jak v programu získat kódování nějakého
textu je pomocí tzv. <em>řetězcového literálu</em>. Zdrojový kód je
samozřejmě také text, je tedy zcela logické, že programovací
jazyky nám umožňují část textu označit za data. Zapíšeme-li
v jazyce C do programu řetězcový literál, překladač v paměti
programu vyhradí potřebné místo a uloží do tohoto místa
kódování uvozeného textu, ukončeno nulovým bajtem. Protože
řetězcový literál je výraz, má hodnotu – tato hodnota je
(opět platí pro jazyk C) <em>ukazatel</em> na takto vyhrazenou
paměť. Je obvyklé, že tato paměť je označena <em>pouze pro
čtení</em>, do paměti řetězcového literálu tedy <em>není dovoleno</em>
zapsat jiná data. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    const char * const string = "hello"; 
</code></pre>
<div class="par">
Pojmenovaná konstanta <code>string</code> nyní obsahuje ukazatel na
paměť, kde je uloženo kódování řetězce <code>hello</code> ukončené
nulovým bajtem. Pro práci s takto uloženými řetězci poskytuje
jazyk C sadu základních funkcí. První z nich je <code>strlen</code>,
která zjistí počet <em>bajtů</em> (nikoliv znaků), kterými je
řetězec zakódovaný. Např.: 
<!-- paragraph -->
</div>
<pre><code class="cxx">    assert( strlen( string ) == 5 ); 
    assert( strlen( "věc" ) == 4 );
</code></pre>
<div class="par">
Pozor, <code>strlen</code> prochází paměť od předaného ukazatele po
bajtech, až dokud nenajde nulový bajt. Není-li na předané
adrese uložen nulou ukončený řetězec, může se stát celkem
cokoliv (včetně chyby ochrany paměti). 
<!-- paragraph -->
</div>
<div class="par">Další užitečnou funkcí je <code>strcmp</code>, která po bajtech srovnává
dvě oblasti paměti, až dokud nenarazí na rozdílný nebo na
nulový bajt. Návratová hodnota je 0, jsou-li na zadaných
adresách uloženy stejné bajty<a class="anchor" id="foothead9" href="#footnote9"><sup>9</sup></a>, záporná je-li levá strana
lexikograficky (po bajtech) menší a kladná jinak. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    assert( strcmp( string, "hello" ) == 0 ); 
</code></pre>
<div class="par">
Protože řetězce jsou v paměti zakódované jako posloupnost
bajtů, můžeme samozřejmě tuto posloupnost bajtů do paměti
uložit přímo.<a class="anchor" id="foothead10" href="#footnote10"><sup>10</sup></a> 
<!-- paragraph -->
</div>
<pre><code class="cxx">    const char thing_1[] = { 0x76, 0xc4, 0x9b, 0x63, 0 }; 
    const char thing_2[] = { 0x76, 0x65, 0xcc, 0x8c, 0x63, 0 };
</code></pre>
<div class="par">
<pre><code class="cxx">    assert( strcmp( "věc",  thing_1 ) == 0 ); 
    assert( strcmp( "věc",  thing_2 ) != 0 );
</code></pre>

Pro tzv. formátovaný výpis můžeme využít knihovní funkce
<code>dprintf</code>. Podrobný popis formátovacího řetězce (druhý
parametr) naleznete v její manuálové stránce (<code>man dprintf</code>).
Nám v tuto chvíli postačí, že za každou <code>%</code>-sekvenci se
při výpisu dosadí postupně další parametry, a že daná
<code>%</code>-sekvence popisuje tzv. <em>konverzi</em>, která určuje, jak se
má daný parametr vypsat. Konverze <code>%s</code> interpretuje příslušný
parametr jako ukazatel na paměť, která kóduje nulou ukončený
řetězec. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    dprintf( STDOUT_FILENO, "%s - %s\n", thing_1, thing_2 ); 
</code></pre>
<div class="par">
Pro výpis číselných hodnot typicky použijeme konverze <code>%d</code>
(desítková) nebo <code>%x</code> (šestnáctková), případně jsou-li
předané hodnoty typu <code>long</code>, použijeme <code>%ld</code> nebo <code>%lx</code>. Pro
desítkový výpis bez znaménka použijeme <code>%u</code> nebo <code>%lu</code>. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    dprintf( STDOUT_FILENO, "%d %u %x\n", thing_1[ 0 ], 
             (unsigned char) thing_1[ 1 ],
             (unsigned char) thing_1[ 2 ] );
</code></pre>
<div class="par">
Krom zápisu do souboru (resp. na standardní výstup) můžeme
někdy potřebovat pomocí formátování nachystat řetězec
v paměti. K tomu lze použít funkci <code>snprintf</code>, které předáme
ukazatel na přichystané místo v paměti, kam bude uloženo
výsledné kódování, počet vyhrazených bajtů, formátovací
řetězec a případné další parametry.
<!-- paragraph -->
</div>
<div class="par">Tato funkce zapíše tolik bajtů výsledného řetězce, kolik
umožní vyhrazené místo. Návratová hodnota pak indikuje, kolik
bajtů bylo potřeba (bez ohledu na to, jestli se do vyhrazené
paměti vešly nebo nikoliv). Poslední zapsaný bajt je vždy
nulový, a to i v situaci, kdy zapsaný řetězec není kompletní.
<!-- paragraph -->
</div>
<!-- paragraph -->
<pre><code class="cxx">    char buffer[ 5 ]; 
    assert( snprintf( buffer, 5, "123456789" ) == 9 );
    assert( strcmp( buffer, "1234" ) == 0 );
</code></pre>
<div class="par">
<pre><code class="cxx">    return 0; 
</code></pre>

<pre><code class="cxx">    // cflags: -Wno-format-truncation 
}
</code></pre>


<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote7" href="#foothead7"><sup>7</sup></a><div class="par"> Co přesně je písmeno je mnohem komplikovanější otázka, než by  se mohlo zdát. Zájemce o obecně uznávanou definici odkazujeme  na normu Unicode. To, co tady zjednodušeně nazýváme písmenem,  je správně tzv. kódový bod.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote8" href="#foothead8"><sup>8</sup></a><div class="par"> ASCII je norma, která popisuje kódování základní 127-znakové  abecedy, používaná původně ve Spojených státech (proto název  „American Standard Code for Information Interchange“), nyní ale  celosvětově, zejména jako podmnožina kódování UTF-8 standardu  Unicode.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote9" href="#foothead9"><sup>9</sup></a><div class="par"> Rádi bychom zde řekli, že funkce srovnává řetězce, to by ale  bylo mírně zavádějící. Některé řetězce lze kódovat více než  jedním ekvivalentním způsobem, např. <code>věc</code> lze v UTF-8  zakódovat jako <code>76 c4 9b 63</code> nebo jako <code>76 65 cc 8c 63</code>. Tyto  sekvence reprezentují tentýž <em>text</em>, ale protože jsou v paměti  uloženy jako různé posloupnosti bajtů, funkce <code>strcmp</code> je bude  považovat za odlišné.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote10" href="#foothead10"><sup>10</sup></a><div class="par"> Toto bude samozřejmě fungovat pouze tehdy, kdy známe konkrétní  kódování používané daným systémem. Spustíte-li tento program na  systému, který nepoužívá UTF-8, výsledky se mohou lišit.  Zejména výstup na obrazovce nebude odpovídat tomu, co bychom  očekávali. <!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Úvod/[‹err›]"><h3>B.d.3 [<code>err</code>]</h3></a> <div class="par">V této ukázce se podíváme na to, jak se lze vypořádat s fatálními
chybami, zejména těmi, které jsou zaviněny selháním systémového
volání. Pro tento účel budeme používat <em>nestandardní</em> rozšíření
v podobě hlavičkového souboru <code>err.h</code>. Tento kompromis volíme ze
dvou důvodů:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>jedná se o velmi široce podporované rozšíření a není
jednoduché nalézt POSIX-kompatibilní operační systém, který
by je neposkytoval,
</li><li>definice funkcí <code>err</code>, <code>errx</code>, <code>warn</code> a <code>warnx</code>, které budeme
v tomto předmětu používat, se vejdou na cca 50 řádků, takže
v případě potřeby je není problém do programů doplnit
(zajímají-li Vás možné definice, naleznete je v poslední
ukázce této kapitoly). 
</li></ol>
<pre><code class="cxx">#include &lt;err.h&gt;        /* err, errx, warn, warnx */ 
#include &lt;stdio.h&gt;      /* dprintf */
#include &lt;unistd.h&gt;     /* STDOUT_FILENO */
</code></pre>

Tento program nedělá nic jiného, než že na standardní výstup
zapíše řetězec. Podle toho, jak ho spustíme, může i tato velmi
jednoduchá operace selhat. Podrobněji se základy vstupu a výstupu
budeme zabývat v první kapitole. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int main( void ) /* demo */ 
{
</code></pre>
<div class="par">Pro vypořádání se s chybou, která není fatální, ale je
žádoucí na ni upozornit uživatele, budeme obvykle používat
proceduru <code>warn</code>, která vypíše chybové hlášení ale pokračuje
ve vykonávání programu. Spustíte-li si tento program např.
příkazem, dostanete výpis, který krom samotné chyby vypíše:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>jméno programu (toto je užitečné zejména ve chvíli, kdy
uživatel spustil několik programů najednou, třeba
spojených rourou)
</li><li>popis poslední <em>systémové</em> chyby – výčet možných chyb
naleznete např. v manuálové stránce <code>man 7p errno</code>.
</li></ol>
Příklad:
<!-- paragraph -->
</div>
<pre><code class="plain">$ ./d3_err &gt; /dev/full
d3_err: write to stdout failed: No space left on device
d3_err: write to stdout failed: No space left on device
$ echo $?
1
</code></pre>
<div class="par">
Všimněte si zejména poslední části chybového výpisu, kde je
uvedeno jakým způsobem poslední systémové volání selhalo. Je
ovšem naším úkolem dodat uživateli dostatečný kontext, aby
mohl tuto část chybového výpisu interpretovat (je například
dobré v první části chyby zmínit s jakým souborem se
pracovalo). 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( dprintf( STDOUT_FILENO, "foo\n" ) == -1 ) 
        warn( "write to stdout failed" );
</code></pre>
<div class="par">
Procedura <code>err</code> pracuje podobně, ale program zároveň ukončí,
a to s návratovým kódem, který jí byl předán v prvním
parametru. Varianty <code>warnx</code> a <code>errx</code> se liší tím, že
nevypisují poslední část, tzn. popis systémové chyby. Můžeme
je tedy použít v situaci, kdy chyba nepochází ze systémového
volání. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( dprintf( STDOUT_FILENO, "bar\n" ) == -1 ) 
        err( 1, "write to stdout failed" );
</code></pre>
<div class="par">
<pre><code class="cxx">    return 0; 
}
</code></pre>


<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Úvod/[‹fail›]"><h3>B.d.4 [<code>fail</code>]</h3></a> <div class="par">Zde si ukážeme několik technik, které nám pomohou vypořádat se
s opravitelnými chybami. Připomínáme, že za opravitelné
považujeme chyby, po kterých může program jako celek smysluplně
pokračovat ve své činnosti. V tomto předmětu to bude zejména
v případech, kdy budeme psát znovupoužitelné podprogramy.
<!-- paragraph -->
</div>
<div class="par">Nastane-li opravitelná chyba, snažíme se dotčený podprogram
ukončit tak, aby:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>nedošlo k úniku zdrojů, tzn. každý zdroj, který podprogram
vyžádal, musí být vrácen, nebo se musí stát součástí stavu
programu (a tedy bude vrácen později, v rámci standardního –
nechybového – úklidu),
</li><li>byly zachovány veškeré požadované invarianty, na které mohl
mít podprogram vliv – v ideálním případě je chování
podprogramu „všechno anebo nic“, tzn. pokud podprogram
neuspěl, nebude mít žádný pozorovatelný efekt,<a class="anchor" id="foothead11" href="#footnote11"><sup>11</sup></a>
</li><li>volající byl o tomto selhání co možná nejpodrobněji
informován. 
</li></ol>
<pre><code class="cxx">#define _POSIX_C_SOURCE 200809L 
#include &lt;unistd.h&gt;     /* read, write */
#include &lt;fcntl.h&gt;      /* openat */
#include &lt;err.h&gt;        /* warn */
#include &lt;errno.h&gt;      /* errno */
</code></pre>

V této ukázce trochu předběhneme učivo a naprogramujeme si
jednoduchou proceduru, která vytvoří kopii souboru v souborovém
systému. Podrobněji se budeme systémovými voláními <code>openat</code>,
<code>read</code> a <code>write</code> zabývat v první kapitole. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int copy_1( int from_dir, const char *from_name, 
            int to_dir, const char *to_name )
{
    int fd_in, fd_out;
</code></pre>
<div class="par">
Voláním <code>openat</code> otevřeme soubor s názvem <code>from_name</code> ve
složce <code>from_dir</code>. Nyní jsou důležité dvě věci:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>systémové volání <code>openat</code> může selhat, například proto,
že požadovaný soubor neexistuje, a s touto situací se
budeme muset vypořádat,
</li><li>je-li soubor úspěšně otevřen, popisovač souboru, který
získáme jako návratovou hodnotu, reprezentuje <em>zdroj</em>
který je nutné později opět uvolnit (systémovým voláním
<code>close</code>). 
</li></ol>
<pre><code class="cxx">    fd_in = openat( from_dir, from_name, O_RDONLY ); 
</code></pre>

Neúspěch volání <code>openat</code> poznáme tak, že <code>fd_in</code> obsahuje
hodnotu -1. Protože v tomto kontextu se jedná o opravitelnou
chybu, podprogram ukončíme. Navíc jsme dosud neprovedli žádné
„viditelné“ akce, tak nemusíme řešit jejich vrácení. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( fd_in == -1 ) 
        return 1;
</code></pre>
<div class="par">
Abychom mohli kopírovat data, musíme otevřít (a případně
vytvořit) i cílový soubor. Opět k tomu použijeme volání
<code>openat</code>. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    fd_out = openat( to_dir, to_name, O_WRONLY | O_CREAT, 0666 ); 
</code></pre>
<div class="par">
Opakuje se zde situace, kdy volání <code>openat</code> může selhat, ale
nyní máme nový problém – první volání <code>openat</code> uspělo a tedy
<code>fd_in</code> odkazuje na <em>alokovaný zdroj</em>, totiž popisovač
souboru. Abychom dodrželi zásadu, že podprogram, který
selhal, by neměl mít žádný efekt, musíme tento popisovač před
návratem uzavřít. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( fd_out == -1 ) 
    {
</code></pre>
<div class="par">Dostáváme se nyní do trochu nešťastné situace, kdy
vrácení zdroje může také selhat. V takové situaci nám
nezbývá, než uživatele varovat a pokračovat ve výpočtu
(alternativně bychom mohli tuto chybu považovat za
fatální a program ukončit).
<!-- paragraph -->
</div>
<div class="par">Volání <code>close</code> na tomto místě přináší ještě jeden problém
– hodnota <code>errno</code>, která popisuje z jakého důvodu selhalo
volání <code>openat</code>, bude při volání <code>close</code> přepsána, a
volající tedy nebude moct hodnotu <code>errno</code> použít. Měli
bychom tedy tuto hodnotu uložit a před návratem
z podprogramu <code>copy_1</code> obsah <code>errno</code> obnovit. Toto platí
o jakémkoliv systémovém volání, nebo podprogramu, který
systémová volání vnitřně používá. Použijeme-li např.
proceduru <code>warn</code>, tato může <code>errno</code> také přepsat. 
<!-- paragraph -->
</div>
<pre><code class="cxx">        int saved_errno = errno; 
</code></pre>
<div class="par">
<pre><code class="cxx">        if ( close( fd_in ) == -1 ) 
            warn( "failed to close file %s", from_name );
</code></pre>

<pre><code class="cxx">        errno = saved_errno; 
        return 1;
    }
</code></pre>

Máme nyní otevřeny oba dotčené soubory. Nyní budeme
potřebovat místo v paměti, do kterého nejprve načteme blok
dat ze vstupního souboru a tento pak obratem zapíšeme do
souboru výstupního. Opět platí, že každá z těchto operací
může selhat a tuto situaci musíme řešit. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    const int nbytes = 1024; 
    char buffer[ nbytes ];
    int bytes_read, bytes_written;
</code></pre>
<div class="par">
<pre><code class="cxx">    do { 
        bytes_read = read( fd_in, buffer, nbytes );
</code></pre>

<pre><code class="cxx">        if ( bytes_read == -1 ) 
        {
</code></pre>
Výsledek -1 znamená, že čtení selhalo. Operaci musíme
ukončit a opět musíme zároveň vrátit vše, co můžeme,
do původního stavu. To už v tuto chvíli nebude možné
zcela splnit, protože volání <code>openat</code> pro výstupní
soubor mohlo tento soubor vytvořit, ale nemůžeme zde
tento soubor odstranit, protože není zaručeno, že pod
jménem <code>to_name</code> ve složce <code>from_dir</code> se stále
nachází soubor, který jsme o několik řádků dříve
vytvořili.  Omezíme se tedy na uvolnění zdrojů. 
<!-- paragraph -->
</div>
<pre><code class="cxx">            int saved_errno = errno; 
</code></pre>
<div class="par">
<pre><code class="cxx">            if ( close( fd_in ) == -1 ) 
                warn( "failed to close file %s", from_name );
            if ( close( fd_out ) == -1 )
                warn( "failed to close file %s", to_name );
</code></pre>

<pre><code class="cxx">            errno = saved_errno; 
            return 2;
        }
</code></pre>

<pre><code class="cxx">        bytes_written = write( fd_out, buffer, bytes_read ); 
</code></pre>

<pre><code class="cxx">        if ( bytes_written == -1 ) 
        {
</code></pre>
A ještě jednou totéž. 
<!-- paragraph -->
</div>
<pre><code class="cxx">            int saved_errno = errno; 
</code></pre>
<div class="par">
<pre><code class="cxx">            if ( close( fd_in ) == -1 ) 
                warn( "failed to close file %s", from_name );
            if ( close( fd_out ) == -1 )
                warn( "failed to close file %s", to_name );
</code></pre>

<pre><code class="cxx">            errno = saved_errno; 
            return 2;
        }
    } while ( bytes_read != 0 );
</code></pre>

Data jsou úspěšně zkopírována, můžeme tedy oba soubory zavřít
a oznámit volajícímu úspěch. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( close( fd_in ) == -1 ) 
        warn( "failed to close file %s", from_name );
    if ( close( fd_out ) == -1 )
        warn( "failed to close file %s", to_name );
</code></pre>
<div class="par">
<pre><code class="cxx">    return 0; 
}
</code></pre>

Jistě jste si všimli, že procedura <code>copy_1</code> obsahuje velké
množství redundantního kódu (a jistě také víte, že to není
dobře). Máme dva základní prostředky, které nám pomohou se
s tímto vypořádat. Jedním jsou pomocné podprogramy. Jako „nízko
visící ovoce“ se nabízí procedura <code>close_or_warn</code>, která nám
zjednoduší zavírání souborů, aniž bychom museli přijmout tzv.
tichá selhání.
<!-- paragraph -->
</div>
<div class="par">Jako dodatečné vylepšení navíc budeme vstupní popisovač
s hodnotou -1 ignorovat – žádný platný popisovač nemůže nikdy mít
tuto hodnotu. Jedná se o podobný „trik“ jako používá knihovní
procedura <code>free</code>, kterou lze bez rizika zavolat na nulový
ukazatel. 
<!-- paragraph -->
</div>
<pre><code class="cxx">void close_or_warn( int fd, const char *name ) 
{
    int saved_errno = errno;
</code></pre>
<div class="par">
<pre><code class="cxx">    if ( fd != -1 &amp;&amp; close( fd ) == -1 ) 
        warn( "failed to close file %s", name );
</code></pre>

<pre><code class="cxx">    errno = saved_errno; 
}
</code></pre>

Druhým prostředkem je poněkud kontroverzní příkaz <code>goto</code>. To, že
budeme někdy <code>goto</code> používat pro ošetření chyb neznamená, že
můžete <code>goto</code> „beztrestně“ použít na cokoliv. Problém, který zde
<code>goto</code> řeší je, že odkazy na zdroje alokované podprogramem
obvykle ukládáme do lokálních proměnných, které bychom případnému
pomocnému „úklidovému“ podprogramu museli vždy všechny předat –
to je zápisově značně nepraktické.<a class="anchor" id="foothead12" href="#footnote12"><sup>12</sup></a> 
<!-- paragraph -->
</div>
<pre><code class="cxx">int copy_2( int from_dir, const char *from_name, 
            int to_dir, const char *to_name )
{
    int fd_in = -1, fd_out = -1;
    int rv = 1;
</code></pre>
<div class="par">
<pre><code class="cxx">    const int nbytes = 1024; 
    char buffer[ nbytes ];
    int bytes_read, bytes_written;
</code></pre>

<pre><code class="cxx">    if ( ( fd_in = openat( from_dir, from_name, O_RDONLY ) ) == -1 ) 
        goto error;
</code></pre>

<pre><code class="cxx">    if ( ( fd_out = openat( to_dir, to_name, O_WRONLY | O_CREAT, 
                            0666 ) ) == -1 )
        goto error;
</code></pre>

<pre><code class="cxx">    rv = 2; 
</code></pre>

<pre><code class="cxx">    do { 
</code></pre>

<pre><code class="cxx">        if ( ( bytes_read = read( fd_in, buffer, nbytes ) ) == -1 ) 
            goto error;
</code></pre>

<pre><code class="cxx">        if ( ( bytes_written = write( fd_out, buffer, 
                                      bytes_read ) ) == -1 )
            goto error;
</code></pre>

Za povšimnutí stojí, že neřešíme situaci, kdy je
<code>bytes_written</code> nezáporné, ale zároveň menší než
<code>bytes_read</code>. Rozpravu na toto téma si necháme na
později. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    } while ( bytes_read != 0 ); 
</code></pre>
<div class="par">
<pre><code class="cxx">    rv = 0; 
</code></pre>

<pre><code class="cxx">error: 
    close_or_warn( fd_in, from_name );
    close_or_warn( fd_out, to_name );
    return rv;
}
</code></pre>

<pre><code class="cxx">int main( void ) /* demo */ 
{
    int wd = openat( AT_FDCWD, ".", O_DIRECTORY );
</code></pre>

<pre><code class="cxx">    if ( wd == -1 ) 
        err( 1, "could not open working directory" );
</code></pre>

<pre><code class="cxx">    const char *src = "a0_intro.txt"; 
    const char *dest = "zt.intro.txt";
</code></pre>

<pre><code class="cxx">    if ( copy_1( wd, src, wd, dest ) != 0 ) 
        warn( "copying %s to %s failed", src, dest );
</code></pre>

<pre><code class="cxx">    if ( copy_2( wd, src, wd, dest ) != 0 ) 
        warn( "copying %s to %s failed", src, dest );
</code></pre>

<pre><code class="cxx">    if ( unlinkat( wd, dest, 0 ) != 0 ) 
        warn( "removing %s failed", dest );
</code></pre>

<pre><code class="cxx">    return 0; 
}
</code></pre>

<!-- paragraph -->
</div>
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote11" href="#foothead11"><sup>11</sup></a><div class="par"> Toto je samozřejmě v praxi těžké stoprocentně zajistit, nicméně  čím blíže se tomuto ideálu dokážeme přiblížit, tím snazší bude  daný podprogram použít v nějakém větším celku. <!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote12" href="#foothead12"><sup>12</sup></a><div class="par"> Oddělení úklidu do pomocného podprogramu má i jiné problémy.  Můžete si zkusit takový úklidový podprogram napsat, abyste  zjistili, jaké kompromisy to obnáší. <!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Základy práce se soubory"><h1>1 Základy práce se soubory</h1></a> <div class="par">Soubor je základní jednotkou práce s perzistentními daty. Rozhraní
pro práci se soubory je ve většině operačních systémů velmi
důležité, a často pokrývá mnohem víc, než jen obyčejné soubory. Více
o souborech a jejich organizaci se dovíte ve třetí kapitole skript.
<!-- paragraph -->
</div>
<div class="par">Z pohledu programátora je důležité rozhraní, které práci se soubory
zprostředkuje – centrálním prvkem je zde <em>popisovač otevřeného
souboru</em>. Jedná se o hodnotu, která je pevně svázaná se <em>souborem</em>.<a class="anchor" id="foothead13" href="#footnote13"><sup>13</sup></a>
Samotný popisovač nemá žádnou vnitřní strukturu, kterou bychom mohli
zkoumat, je definován pouze operacemi, které je nad ním možné
provádět (jedná se v tomto smyslu o abstraktní datový typ).
<!-- paragraph -->
</div>
<div class="par">Pro vytvoření popisovače existuje několik systémových volání, ze
kterých si tento týden ukážeme to nejdůležitější – <code>openat</code>. Má 3
pevné a 1 volitelný parametr:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li><code>int fd</code> je již existující popisovač, který je svázán <em>se
složkou</em>, vůči které budeme uvádět <em>cestu</em> – lze použít
symbolickou hodnotu <code>AT_FDCWD</code>, která označuje tzv. pracovní
složku,
</li><li><code>const char *path</code> je řetězec (ukončený nulou), který udává
název, případně cestu (oddělovačem je znak <code>/</code>) k souboru, se
kterým hodláme pracovat,
</li><li><code>int flags</code> je bitová kombinace příznaků – budou nás pro tuto
chvíli zajímat symbolické hodnoty:
<ul><li><code>O_RDONLY</code>, <code>O_WRONLY</code> a <code>O_RDWR</code>, které určí jaké operace
plánujeme později se souborem provádět,
</li><li><code>O_CREAT</code> která nám umožní vytvořit nový obyčejný soubor,
</li></ul></li><li><code>int mode</code> dodáváme pouze tehdy, když může operací vzniknout
nový soubor (zejména obsahuje-li parametr <code>flags</code> příznak
<code>O_CREAT</code>).
</li></ol>
Pro čtení a zápis bloků dat (bajtů) slouží operace <code>read</code> a <code>write</code>
(jejich rozhraní je blíže popsané v ukázkách níže). Pro textový
(tzv. formátovaný) zápis je určena funkce <code>dprintf</code>.<a class="anchor" id="foothead14" href="#footnote14"><sup>14</sup></a>
<!-- paragraph -->
</div>
<div class="par">Konečně se v této kapitole budeme zabývat tím, že funkce, které
zprostředkují služby operačního systému mohou v naprosté většině
případů <em>selhat</em>. Tuto skutečnost obvykle indikují speciální
<em>návratovou hodnotou</em> a konkrétní problém upřesňuje proměnná
<code>errno</code>.<a class="anchor" id="foothead15" href="#footnote15"><sup>15</sup></a>
<!-- paragraph -->
</div>
<div class="par">Ukázky:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li><code>read</code>   – otevření a čtení obyčejného souboru,
</li><li><code>hello</code>  – standardní vstup a výstup,
</li><li><code>dirs</code>   – práce se složkami a funkce <code>openat</code>.
</li></ol>
Přípravy:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li><code>lines</code>  – počítání znaků konce řádku, chyba není-li správně ukončen
</li><li><code>bwconv</code> – jednoduchý převod obrázku ze stupňů šedi na černobílý
</li><li><code>catfd</code>  – použití <code>read</code> a <code>write</code>
</li><li><code>cols</code>   – konverze csv s čísly na zarovnané sloupce (<code>dprintf</code>)
</li><li><code>cut</code>    – openat + read/write ← cut
</li><li><code>cat</code>    – soubor se jmény souborů, které se mají spojit
</li></ol>
Rozšířené:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li><code>wcount</code>  – počítání slov (přechod bílý/nebílý)
</li><li><code>cgrep</code>   – výpis řádků, které obsahují zadaný znak
</li><li><code>flake</code>   – kontrola souboru s vyobrazením padající vločky
</li><li><code>bcount</code>  – kolik různých bajtů se objevuje v souboru?
</li><li><code>linked</code>  – procházení zřetězeného seznamu souborů
</li><li><code>otp</code>     – xor dvou souborů (one time pad)
</li></ol>
<!-- paragraph -->
</div>
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote13" href="#foothead13"><sup>13</sup></a><div class="par"> Nikoliv s cestou, nebo jiným nepřímým pojmenováním nebo označením.  Identita již otevřeného souboru se nám nemůže „změnit pod rukama“.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote14" href="#foothead14"><sup>14</sup></a><div class="par"> Podobá se funkci <code>printf</code>, kterou již možná znáte z předchozího  programování v jazyce C.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote15" href="#foothead15"><sup>15</sup></a><div class="par"> Tuto proměnnou nelze striktně vzato označit za globální, protože  každé vlákno má vlastní verzi. Implementace takové proměnné je  komplikovaná a jde mimo rámec tohoto kurzu.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Základy práce se soubory/Demonstrace (ukázky)"><h2>1.d Demonstrace (ukázky)</h2></a> <!-- paragraph -->
<a name="Základy práce se soubory/[‹read›]"><h3>1.d.1 [<code>read</code>]</h3></a> <div class="par">Tento jednoduchý program demonstruje POSIXové rozhraní pro práci
s obyčejným souborem. Jako obvykle začneme direktivami <code>#define
_POSIX_C_SOURCE</code> a <code>#include</code> – budeme potřebovat hlavičku
<code>unistd.h</code>, která deklaruje většinu systémových volání (nás bude
v tuto chvíli zajímat pouze <code>read</code>), a také hlavičku <code>fcntl.h</code>,
která deklaruje <code>openat</code> (tato jako jedna z mála není deklarována
v <code>unistd.h</code>). 
<!-- paragraph -->
</div>
<pre><code class="cxx">#define _POSIX_C_SOURCE 200809L 
</code></pre>
<div class="par">
<pre><code class="cxx">#include &lt;unistd.h&gt;  /* read, write */ 
#include &lt;fcntl.h&gt;   /* openat */
#include &lt;string.h&gt;  /* memcmp */
#include &lt;err.h&gt;     /* err */
</code></pre>

Protože se jedná o velmi jednoduchý program, bude obsahovat pouze
proceduru <code>main</code>. Jak si jistě pamatujete, jedná se o vstupní bod
programu (spustíme-li přeložený program, začne se vykonávat
odsud). 
<!-- paragraph -->
</div>
<pre><code class="cxx">int main( void ) /* demo */ 
{
</code></pre>
<div class="par">Začneme tím, že otevřeme soubor pro čtení. Z úvodu víme, že
k tomu slouží systémové volání <code>openat</code>, které má v tomto
případě 3 parametry. Prozatím se omezíme na soubory
v <em>pracovní složce</em> spuštěného programu, jako první parametr
tedy předáme <code>AT_FDCWD</code> (aby program správně pracoval, musíte
jej spustit přímo ve složce <code>01</code>).
<!-- paragraph -->
</div>
<div class="par">Dalším parametrem je <em>název souboru</em> který chceme otevřít,
formou řetězce (ukončeného nulou). Krom samotného názvu zde
může stát i cesta (relativní nebo absolutní), ale pro tuto
chvíli se opět omezíme na práci s jedinou složkou (tou
pracovní).
<!-- paragraph -->
</div>
<div class="par">Konečně příznak <code>O_RDONLY</code> specifikuje, že ze souboru hodláme
pouze číst (<code>O</code> od <code>open</code>, <code>RDONLY</code> od <code>read only</code>). 
<!-- paragraph -->
</div>
<pre><code class="cxx">    const char * const filename = "zz.foo.txt"; 
</code></pre>
<div class="par">
<pre><code class="cxx">    int fd = openat( AT_FDCWD, filename, O_RDONLY ); 
</code></pre>

<code>fd</code> je tradiční název proměnné, která uchovává popisovač
otevřeného souboru (z angl. <em>f</em>ile <em>d</em>escriptor; samozřejmě
tento název lze použít pouze v situaci, kdy pracujeme
s jediným popisovačem). Za povšimnutí stojí typ této proměnné
– POSIX specifikuje, že popisovače souborů jsou typu <code>int</code>.
<!-- paragraph -->
</div>
<div class="par">Než budeme pokračovat, musíme (jako u prakticky každého
systémového volání) ověřit, že otevření souboru proběhlo
v pořádku. Manuálová stránka pro systémové volání <code>open</code>
(otevřete ji příkazem <code>man 2 open</code>) v sekci „return value“
píše:
<!-- paragraph -->
</div>
<blockquote>
<div class="par">If successful, <code>open()</code> returns a non-negative integer,
termed a file descriptor.  Otherwise, a value of -1 is
returned and <code>errno</code> is set to indicate the error. 
</blockquote>
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( fd == -1 ) /* this would indicate an error */ 
</code></pre>
<div class="par">
Protože se jedná o kompletní program (nikoliv samostatnou
funkci), lze tento typ chyby chápat jako fatální a
program s odpovídající chybovou hláškou ukončit. K tomu
použijeme proceduru <code>err</code>, kterou již známe z kapitoly B.
<!-- paragraph -->
</div>
<!-- paragraph -->
<pre><code class="cxx">        err( 1, "opening file %s", filename ); 
</code></pre>
<div class="par">
Protože procedura <code>err</code> ukončí program, dostaneme-li se do
tohoto místa, víme, že volání <code>open</code> uspělo a <code>fd</code> obsahuje
platný popisovač, ze kterého lze číst. Čtení provedeme
voláním <code>read</code>, kterému musíme krom popisovače předat
ukazatel na paměť, do které data přečtená ze souboru uloží
(angl. obvykle označované jako <code>buffer</code>).
<!-- paragraph -->
</div>
<div class="par">Konečně poslední parametr určuje kolik <em>nejvýše</em> bajtů má být
přečteno. Tomuto parametru musíme věnovat zvláštní pozornost:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>Bajtů může být přečteno méně, než jsme žádali – kolik
jich bylo skutečně přečteno zjistíme až z návratové
hodnoty.
</li><li>Vedlejším efektem volání <code>read</code> je, že do paměti určené
adresou <code>buffer</code> bude zapsáno až <code>nbytes</code> bajtů (volání
tedy přepíše hodnoty na adresách <code>buffer + 0</code>, <code>buffer +
1</code>, …, <code>buffer + nbytes - 1</code>). Abychom si omylem
nezničili nějaká nesouvisející data, musíme systémovému
volání <code>read</code> předat adresu, od které máme vyhrazeno
alespoň <code>nbytes</code> bajtů.
</li></ol>
Jednoduchý způsob, jak vyhradit pevný počet bajtů v paměti,
je deklarací lokálního pole. Počet bajtů, které hodláme
načíst, si uložíme do pojmenované konstanty <code>nbytes</code>. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    const int nbytes = 16; 
    const int expect = 4;
</code></pre>
<div class="par">
<pre><code class="cxx">    char buffer[ nbytes ]; 
    ssize_t bytes_read = read( fd, buffer, nbytes );
</code></pre>

Jako každé systémové volání může <code>read</code> selhat. Podobně jako
u volání <code>open</code> tuto skutečnost indikuje návratová hodnota
-1.<a class="anchor" id="foothead16" href="#footnote16"><sup>16</sup></a>
<!-- paragraph -->
</div>
<div class="par">Pozor, návratová hodnota <code>0</code> <em>není chybou</em> (říká nám pouze,
že žádné další bajty přečíst nelze, protože jsme narazili na
konec souboru). 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( bytes_read == -1 ) 
        err( 1, "error reading from %s", filename );
</code></pre>
<div class="par">
Dále ověříme, že jsme načetli data, která jsme očekávali.
Protože se v těchto případech nejedná o systémové chyby,
použijeme místo procedury <code>err</code> proceduru <code>errx</code>, která
nevypisuje chybu uloženou v proměnné <code>errno</code>. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( bytes_read &lt; expect ) 
        errx( 1, "file %s was shorter than expected, only %zd bytes",
              filename, bytes_read );
</code></pre>
<div class="par">
<pre><code class="cxx">    if ( memcmp( buffer, "foo\n", expect ) ) 
        errx( 1, "file %s has unexpected content", filename );
</code></pre>

Po dokončení práce se souborem tento uzavřeme. Všimněte si,
že v případě chyby čtení jsme popisovač neuzavřeli – to si
můžeme dovolit pouze v situaci, kdy zároveň ukončujeme celý
program (tím jsou veškeré zdroje automaticky uvolněny).
<!-- paragraph -->
</div>
<div class="par">Systémové volání <code>close</code> může opět selhat, nicméně situace,
kdy se můžeme s takovou chybou smysluplně vypořádat jsou
relativně vzácné. Měli bychom ale v každém případě o takovém
selhání uživatele informovat, protože tento typ chyby může
znamenat ztrátu dat, která program do souboru zapisoval. To,
co naopak udělat <em>nesmíme</em>, je pokusit se soubor zavřít
podruhé – v závislosti na systému a okolnostech mohl být
popisovač uzavřen i přesto, že volání <code>close</code> selhalo (a ani
nemáme jak zjistit, jestli k tomu došlo nebo nikoliv). 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( close( fd ) != 0 ) 
        warn( "error closing %s", filename );
</code></pre>
<div class="par">
Návratová hodnota 0 značí, že program bez chyby doběhl. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    return 0; 
}
</code></pre>
<div class="par">

<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote16" href="#foothead16"><sup>16</sup></a><div class="par"> Všimněte si, že proměnnou <code>bytes</code> jsme deklarovali s typem  <code>ssize_t</code> – jedná se o <em>znaménkový</em> typ, na rozdíl od podobně  pojmenovaného typu <code>size_t</code>. <!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Základy práce se soubory/[‹hello›]"><h3>1.d.2 [<code>hello</code>]</h3></a> <div class="par">Krom obyčejných souborů lze popisovače využít k práci s řadou
dalších podobných zdrojů. V tomto programu si ukážeme, jak
pracovat s takzvaným standardním vstupem a výstupem (angl.
standard input/output, nebo také stdio). Tento se v systémech
POSIX skládá ze tří částí, reprezentovaných třemi popisovači:<a class="anchor" id="foothead17" href="#footnote17"><sup>17</sup></a>
<!-- paragraph -->
</div>
<div class="par"><ul><li>standardní vstup, na popisovači číslo 0, symbolicky
<code>STDIN_FILENO</code>, který je implicitně „připojený ke klávesnici“
(čtením z tohoto popisovače získáme bajty, které uživatel
zadal do terminálu po spuštění programu),
</li><li>standardní výstup, na popisovači číslo 1, symbolicky
<code>STDOUT_FILENO</code>, který je implicitně „připojený k obrazovce“
(zápisem do tohoto popisovače zobrazujeme data na obrazovku
terminálu),
</li><li>standardní <em>chybový</em> výstup, na popisovači číslo 2, symbolicky
<code>STDERR_FILENO</code>, který je implicitně spojen s předchozím a
tedy odesílán na obrazovku.
</li></ul>
Přesto, že se na pohled chovají zaměnitelně, je mezi standardním
výstupem a standardním chybovým výstupem klíčový <em>sémantický</em>
rozdíl – výstup běžného neinteraktivního programu lze pomyslně
rozdělit do dvou oddělených proudů:
<!-- paragraph -->
</div>
<div class="par"><ul><li>užitný výstup, který je hlavním výsledkem výpočtu a tzv.
</li><li>diagnostický výstup, který obsahuje informace o průběhu
výpočtu, zejména o chybách.
</li></ul>
Nikoho zřejmě nepřekvapí, že tyto dva typy výstupů patří každý na
odpovídající typ standardního výstupu. Důležitým efektem tohoto
rozdělení je, že když standardní výstup <em>přesměrujeme</em> (např. do
souboru, nebo na vstup dalšího programu), nebudou se do dat
určených k dalšímu zpracování míchat diagnostické výstupy –
naopak, uživateli budou nadále přístupné na obrazovce.<a class="anchor" id="foothead18" href="#footnote18"><sup>18</sup></a> 
<!-- paragraph -->
</div>
<pre><code class="cxx">#include &lt;unistd.h&gt; /* write, STDIN_FILENO, … */ 
#include &lt;stdio.h&gt;  /* dprintf */
#include &lt;err.h&gt;    /* err */
</code></pre>
<div class="par">
<pre><code class="cxx">int main( void ) /* demo */ 
{
</code></pre>
Veškerý výstup do popisovače otevřeného souboru je realizován
systémovým voláním <code>write</code>.<a class="anchor" id="foothead19" href="#footnote19"><sup>19</sup></a> Zejména veškeré sofistikované
knihovní funkce pro výstup (např. <code>dprintf</code>, ale třeba i
procedury z rodiny <code>err</code>) nakonec výstup realizují voláním
<code>write</code>. Systémové volání <code>write</code> je ve svém principu velmi
jednoduché: předáme mu relevantní popisovač, ukazatel na
paměť a počet bajtů, které má vypsat. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    const int nbytes = 5; 
    int bytes_written = write( STDOUT_FILENO, "hello", nbytes );
</code></pre>
<div class="par">
Uspěje-li volání <code>write</code>, náš program právě na standardní
výstup zapsal 5 bajtů, 0x68, 0x65, 0x6c, 0x6c a konečně 0x6f
(viz také <code>man ascii</code>). Úspěch ale ani u takto na první
pohled jednoduché operace není zaručen. Výstup mohl být
například uživatelem přesměrován do souboru nebo do roury.
Za určitých okolností může také zápis uspět částečně, ale
touto situací se prozatím nebudeme zabývat.<a class="anchor" id="foothead20" href="#footnote20"><sup>20</sup></a>
<!-- paragraph -->
</div>
<div class="par">Protože standardní výstup a standardní chybový výstup nemusí
být tentýž objekt, má i v případě selhání zápisu na
standardní výstup smysl zapsat na chybový výstup hlášení
o chybě. Je již na uživateli, aby chybový výstup směroval na
podle možnosti spolehlivá zařízení. Krom ukončení programu
s chybovým kódem nemáme žádnou možnost, jak na chybu při
výpisu chybové hlášky reagovat. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( bytes_written == -1 ) 
        err( 1, "write to stdout failed" );
</code></pre>
<div class="par">
Krom přímého použití systémového volání <code>write</code> budeme
k zápisu používat knihovní proceduru <code>dprintf</code>, která nám
umožní jednodušeji sestavovat textové zprávy. Protože
<code>dprintf</code> vnitřně používá systémová volání, která mohou
(opět) selhat, musí se s případnou chybou nějak vypořádat.
Protože se jedná o knihovní podprogram, který by měl být
použitelný v mnoha různých situacích, prakticky jedinou
rozumnou možností je informaci o selhání předat volajícímu.
Podobně jako samotná systémová volání k tomu používá
návratovou hodnotu. Rychlý pohled do <code>man dprintf</code> nám sdělí,
že výsledkem funkce je počet zapsaných bajtů, resp. -1 pokud
nastala nějaká chyba. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( dprintf( STDOUT_FILENO, " world\n" ) == -1 ) 
        err( 1, "write to stdout failed" );
</code></pre>
<div class="par">
Konečně vypíšeme nějaký text i na chybový výstup. Protože
selhání výstupu v tomto případě nemáme jak dále
diagnostikovat, program pouze ukončíme s chybou. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    if ( dprintf( STDERR_FILENO, "hello stderr\n" ) == -1 ) 
        return 2;
</code></pre>
<div class="par">
Abyste si ověřili, že rozumíte tomu, jak se tento program
chová, zkuste si jej spustit následovnými způsoby, a ujistěte
se, že jste tento výsledek očekávali (soubor <code>/dev/full</code>
simuluje situaci, kdy dojde místo v souborovém systému – není
standardizován, ale na stroji <code>aisa</code> je k dispozici):
<!-- paragraph -->
</div>
<pre><code class="plain">$ ./d2_hello
$ ./d2_hello &gt; /dev/null
$ ./d2_hello &gt; /dev/full
$ ./d2_hello 2&gt; /dev/null
$ ./d2_hello 2&gt; /dev/full
</code></pre>
<div class="par">
Návratový kód programu si můžete bezprostředně po jeho
ukončení vypsat příkazem <code>echo $?</code> (platí interprety příkazů,
které se drží normy POSIX). 
<!-- paragraph -->
</div>
<pre><code class="cxx">    return 0; 
}
</code></pre>
<div class="par">

<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote17" href="#foothead17"><sup>17</sup></a><div class="par"> Součástí jazyka C (nezávisle na standardu POSIX) jsou knihovní  funkce pro práci standardním vstupem a výstupem, které možná  znáte. Patří sem např. procedury <code>printf</code>, <code>fprintf</code>, <code>puts</code>,  atp. – tyto můžete v principu používat jako ladící pomůcky, ale  v hotových programech se jim raději vyhněte. Potřebujete-li  alternativu k <code>fprintf</code>, použijte <code>dprintf</code>. <em>Pozor</em>! Programy,  které míchají vstupně-výstupní prostředky jazyka C s těmi  POSIX-ovými, jsou náchylné na těžko odhalitelné chyby (zejména  při nesprávném nebo chybějícím použití procedury <code>fflush</code>).<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote18" href="#foothead18"><sup>18</sup></a><div class="par"> Mohli byste mít pocit, že výstup Vašeho programu nebude nikdo  dále automaticky zpracovávat a tedy na toto rozdělení nemusíte  dbát. Uvědomte si ale, že i běžné použití programu <code>grep</code> pro  vyhledání relevantních řádků ve výstupu na toto rozdělení  spoléhá. Uvažte situaci, kdy <code>./program | grep system</code> nic  nevypíše – je to proto, že program selhal, ale <code>grep</code> chybovou  hlášku z výstupu odstranil, nebo proto, že žádný řádek ve  výpisu neobsahoval řetězec <code>system</code>?<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote19" href="#foothead19"><sup>19</sup></a><div class="par"> Nebo některou jeho variantou – <code>pwrite</code>, <code>writev</code>, <code>pwritev</code>,  které jdou ale nad rámec tohoto předmětu.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote20" href="#foothead20"><sup>20</sup></a><div class="par"> Situace s částečnými zápisy je poněkud komplikovaná – pro  blokující popisovač (případ, kdy by byl standardní vstup nebo  výstup nastaven do neblokujícího režimu, nebudeme řešit) může  být zápis (nebo analogicky i čtení) přerušeno signálem. Protože  naše programy nebudou signály obsluhovat, doručení signálu  zároveň ukončí program, a tedy částečné zápisy nebo čtení  nemusíme řešit, není-li pro to speciální důvod (např. použití  neblokujících popisovačů – <code>O_NONBLOCK</code>). <!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Základy práce se soubory/[‹dirs›]"><h3>1.d.3 [<code>dirs</code>]</h3></a> <div class="par">V této ukázce si trochu více přiblížíme systémové volání <code>openat</code>
a podíváme se na základy práce se složkami (adresáři). Jak víte
z třetí přednášky PB152, složka asociuje jména<a class="anchor" id="foothead21" href="#footnote21"><sup>21</sup></a> se soubory
(v obecném smyslu, tzn. nejen obyčejnými).
<!-- paragraph -->
</div>
<div class="par">Složku lze otevřít stejně jako jiné typy souborů – takto získaný
popisovač tuto složku jednoznačně identifikuje, a to i v situaci,
kdy se změní odkazy na tuto složku, a tedy její jméno v nadřazené
složce nemusí platit, nebo se může přesunout v adresářové
struktuře na úplně jiné místo.<a class="anchor" id="foothead22" href="#footnote22"><sup>22</sup></a> 
<!-- paragraph -->
</div>
<pre><code class="cxx">#include &lt;stdio.h&gt;      /* dprintf */ 
#include &lt;unistd.h&gt;     /* read, write */
#include &lt;fcntl.h&gt;
#include &lt;err.h&gt;
</code></pre>
<div class="par">
Nejprve si nachystáme několik jednoduchých pomocných podprogramů,
které nám zjednoduší zápis zbytku programu. Protože se jedná
o malý uzavřený program, můžeme si dovolit považovat chyby při
otevírání souboru za fatální. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int open_or_die( int dir_fd, const char *path, int flags ) 
{
    int fd = openat( dir_fd, path, flags );
</code></pre>
<div class="par">
<pre><code class="cxx">    if ( fd == -1 ) 
        err( 1, "error opening %s", path );
</code></pre>

<pre><code class="cxx">    return fd; 
}
</code></pre>

<pre><code class="cxx">void close_or_warn( int fd, const char *name ) 
{
    if ( close( fd ) == -1 )
        warn( "error closing descriptor %d for file %s", fd, name );
}
</code></pre>

<pre><code class="cxx">int main( int argc, const char **argv ) /* demo */ 
{
</code></pre>
Tento program bude postupně otevírat soubory, kterých jména
jsou uložené v následujícím poli ukazatelů, a z každého
vypíše prvních pár bajtů na standardní výstup. Nulový
ukazatel označuje konec pole. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    const char * const filenames[] = 
    {
        "a0_intro.txt",
        "a1_overview.txt",
        "a2_grading.txt",
        NULL
    };
</code></pre>
<div class="par">
Aby se nám s programem lépe experimentovalo, spustíme-li jej
s parametrem, tento parametr se použije jako cesta ke složce,
ve které budeme hledat složku <code>00</code> (a v ní pak výše uvedené
soubory). Doporučujeme zkusit si tento program spustit
s různě přichystanými složkami, např. takovou, která
podsložku <code>00</code> vůbec neobsahuje, s takovou, která neobsahuje
všechny očekávané soubory, atp. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    const char *top_path = argc &gt; 1 ? argv[ 1 ] : ".."; 
    int top_fd = open_or_die( AT_FDCWD, top_path, O_DIRECTORY );
    int dir_fd = open_or_die( top_fd, "00", O_DIRECTORY );
</code></pre>
<div class="par">
Následující cyklus každý soubor otevře – všimněte si, že
používáme pouze <em>jména</em> souborů, protože rodičovská složka je
do podprogramu <code>open_or_die</code> předána pomocí popisovače. Tento
přístup má dvě zásadní výhody:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>nemusíme složitě konstruovat <em>cesty</em>, které by k souborům
vedly – něco jako <code>top_path + "/00/" + name</code> – zápis,
který v jazyce C samozřejmě nemůžeme použít; navíc
</li><li>takto sestavené cesty mohou v různých iteracích ukazovat
na soubory v různých složkách – souborový systém je
<em>sdílený</em> a každá operace je potenciálním <em>hazardem
souběhu</em>.<a class="anchor" id="foothead23" href="#footnote23"><sup>23</sup></a> 
</li></ol>
<pre><code class="cxx">    for ( int i = 0; filenames[ i ]; ++i ) 
    {
        const char *name = filenames[ i ];
        int file_fd = open_or_die( dir_fd, name, O_RDONLY );
</code></pre>

<pre><code class="cxx">        const int nbytes = 10; 
        char buffer[ nbytes ];
</code></pre>

<pre><code class="cxx">        int bytes_read = read( file_fd, buffer, nbytes ); 
</code></pre>

<pre><code class="cxx">        if ( bytes_read == -1 ) 
            err( 1, "error reading %d bytes from %s",
                 nbytes, name );
</code></pre>

Přečtené bajty přepíšeme na standardní výstup a posuneme
se na nový řádek. 
<!-- paragraph -->
</div>
<pre><code class="cxx">        if ( write( STDOUT_FILENO, buffer, bytes_read ) == -1 || 
             dprintf( STDOUT_FILENO, "\n" ) == -1 )
            err( 1, "error writing to stdout" );
</code></pre>
<div class="par">
<pre><code class="cxx">        close_or_warn( file_fd, name ); 
    }
</code></pre>

Nezapomeneme uzavřít popisovače složek, které jsme otevřeli
na začátku podprogramu. 
<!-- paragraph -->
</div>
<pre><code class="cxx">    close_or_warn( dir_fd, "00" ); 
    close_or_warn( top_fd, top_path );
    return 0;
}
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote21" href="#foothead21"><sup>21</sup></a><div class="par"> Jméno souboru je libovolný řetězec, který ovšem nesmí obsahovat  znak <code>/</code> ani nulový znak. Délka jména může být operačním  systémem nebo souborovým systémem omezená.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote22" href="#foothead22"><sup>22</sup></a><div class="par"> Protože na složky není dovoleno vytvořit víc než jeden  standardní odkaz, a zároveň není možné neprázdnou složku  odstranit, mohlo by se zdát, že tato situace nemá jak nastat.  Odkazy na složky lze ale atomicky <em>přesouvat</em> použitím  systémového volání <code>renameat</code>. Více si o něm povíme v páté  kapitole.<!-- paragraph -->
</div>
</div><div class="footnote"><a class="anchor" id="footnote23" href="#foothead23"><sup>23</sup></a><div class="par"> Uvažme situaci, kdy všechny vstupní soubory v zadané složce  existují. Sestavujeme-li cesty jak bylo naznačeno, může se  stát, že jiný program složku přejmenuje. Náš program některé  soubory úspěšně vypíše a u jiných ohlásí chybu, a to přesto, že  se soubory ani s odkazy na ně v rodičovské složce se vůbec nic  nestalo. Považujeme-li takovéto chování za chybné (a bylo by to  naprosto logické), prakticky celý náš program tvoří kritickou  sekci vůči přesunu (přejmenování) rodičovské složky, kterou ale  nemáme jak ochránit. Řešení s předáváním složky pomocí  popisovače tuto kritickou sekci (a tedy ani popsaný hazard  souběhu) neobsahuje. <!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Základy práce se soubory/Přípravy"><h2>1.p Přípravy</h2></a> <!-- paragraph -->
<a name="Základy práce se soubory/[‹lines›]"><h3>1.p.1 [<code>lines</code>]</h3></a> <div class="par">POSIX definuje řádek jako posloupnost libovolných znaků
zakončenou znakem nového řádku <code>\n</code> (U+000A, označovaný <code>line
feed</code> nebo též <code>newline</code>).
<!-- paragraph -->
</div>
<div class="par">Implementujte podprogram <code>count_lines</code>, který spočítá řádky na
vstupu daném popisovačem <code>fd</code> a ověří, zda vstup neobsahuje žádné
nekompletní řádky. Počet (kompletních) řádků vrátí skrze ukazatel
<code>count</code>.
<!-- paragraph -->
</div>
<div class="par">Vstup zpracovávejte postupně po malých částech (množství paměti
potřebné pro spuštění programu by nemělo záviset na velikosti
vstupu).
<!-- paragraph -->
</div>
<div class="par">Návratová hodnota bude:
<!-- paragraph -->
</div>
<div class="par"><ul><li><code>0</code> proběhlo-li vše v pořádku,
</li><li><code>1</code> obsahuje-li soubor nekompletní řádek,
</li><li><code>2</code> v případě selhání čtení nebo jiné systémové chyby
(v tomto případě navíc není určeno, jaká hodnota bude zapsána
do výstupního parametru <code>count</code>). 
</li></ul>
<pre><code class="cxx">int count_lines( int fd, int *count ); 
</code></pre>

<!-- paragraph -->
</div>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Základy práce se soubory/[‹bwconv›]"><h3>1.p.2 [<code>bwconv</code>]</h3></a> <div class="par">Úkolem je naprogramovat proceduru <code>bwconv</code>, která převede obrázek
ve formátu BMP ze stupňů šedi do černé a bílé. Výsledný obrázek
tak bude obsahovat pixely pouze těchto dvou barev.
<!-- paragraph -->
</div>
<div class="par">Procedura přijímá parametry:
<ul><li><code>fd_in</code> – popisovač pro vstupní bitmapová data;
</li><li><code>w</code> – šířka obrázku;
</li><li><code>h</code> – výška obrázku;
</li><li><code>fd_out</code> – výstupní popisovač;
</li><li><code>threshold</code> – mez rozdělující bílou a černou (hodnota 0–255).
</li></ul>
Na vstupu může procedura očekávat pouze bitmapová data (tedy
o hlavičku je postaráno se jinde) a stejně tak bude zapisovat
pouze výsledná bitmapová data bez hlavičky.
<!-- paragraph -->
</div>
<div class="par">Data budou takového formátu, že jeden bajt = jeden pixel (tedy 8
bitů na pixel). Formát BMP navíc definuje, že každý řádek musí
být uložen tak, aby jeho délka v bajtech byla dělitelná 4, tedy
po přečtení <code>w</code> bajtů budou na řádku další 0 až 3 bajty, které
výsledný obrázek nijak neovlivní. Můžete předpokládat, že na
vstupu bude hodnota těchto bajtů 0.
<!-- paragraph -->
</div>
<div class="par">Pro každý bajt určující barvu zapište na výstup černou (hodnotu
0) je-li vstupní barva <em>menší nebo rovna</em> hodnotě <code>threshold</code> a
bílou (<code>255</code>) jinak.
<!-- paragraph -->
</div>
<em><div class="par">Pozor!</em> Když budete srovnávat vstupní bajty s hodnotou
<code>threshold</code>, dejte si pozor na implicitní konverze. Ujistěte se,
že konverze mezi použitými číselnými typy proběhne tak, jak
očekáváte.
<!-- paragraph -->
</div>
<div class="par">Návratová hodnota: <code>0</code> – úspěch; <code>-1</code> – systémová chyba.
<!-- paragraph -->
</div>
<div class="par">Při testování může přijít vhod příkaz <code>od -t x1</code> na prohlížení
jednotlivých bajtů obrázku. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int bwconv( int fd_in, int w, int h, int fd_out, int threshold ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Základy práce se soubory/[‹catfd›]"><h3>1.p.3 [<code>catfd</code>]</h3></a> <div class="par">V tomto příkladu bude úkolem implementovat proceduru, jejíž
chování se podobá standardnímu programu <code>cat</code>.
<!-- paragraph -->
</div>
<div class="par">Procedura <code>catfd</code> přijímá 3 parametry:
<!-- paragraph -->
</div>
<div class="par"><ul><li><code>fds</code> – ukazatel na pole popisovačů,
</li><li><code>count</code> – počet popisovačů zde uložený,
</li><li><code>out_fd</code> – výstupní popisovač.
</li></ul>
Účelem této procedury bude přečíst veškerá data z každého
popisovače (v zadaném pořadí) a ta zapsat do výstupního
popisovače. Pokud vše proběhne bez chyby, vrátí 0, jinak skončí
při první chybě a vrátí -1. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int catfd( int *fds, int count, int out_fd ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Základy práce se soubory/[‹cols›]"><h3>1.p.4 [<code>cols</code>]</h3></a> <div class="par">Vaším úkolem je implementovat proceduru <code>write_aligned</code>, jejímž
účelem bude na výstupní popisovač vypsat tabulku v níže popsaném
formátu, avšak doplněnou o mezery tak, aby byl každý sloupec
zarovnaný vpravo. Zároveň by měl být použit minimální nutný počet
takových mezer.
<!-- paragraph -->
</div>
<div class="par">CSV je velmi jednoduchý formát na ukládání tabulek. Jelikož však
neexistuje<a class="anchor" id="foothead24" href="#footnote24"><sup>24</sup></a> jediný standard, který by byl všeobecně dodržován, je
možné se setkat s množstvím rozdílných variant.
<!-- paragraph -->
</div>
<div class="par">Pro toto zadání uvažme následující:
<!-- paragraph -->
</div>
<div class="par"><ul><li>Hodnoty jsou ukládány <em>oddělené</em> znakem čárky <code>,</code> – U+002C.
</li><li>Počet hodnot na každém řádku odpovídá počtu sloupců.
Všechny řádky tak musí obsahovat stejný počet hodnot, jinak
by se nejednalo o validní tabulku.
</li><li>Každý řádek je <em>zakončen</em> znakem <code>\n</code> (U+000A, označovaný
<code>line feed</code> nebo též <code>newline</code>).
</li></ul>
Protože budeme beztak hodnoty zarovnávat mezerami, pro lepší
čitelnost budeme také za každou oddělovací čárkou zapisovat
alespoň jednu mezeru. Procedura akceptuje čtyři parametry:
<!-- paragraph -->
</div>
<div class="par"><ul><li><code>fd</code> – <em>výstupní</em> popisovač, na který má být zapsána
vpravo zarovnaná tabulka;
</li><li><code>values</code> – ukazatel na pole celočíselných hodnot o velikosti
alespoň <code>cols × rows</code>;
</li><li><code>cols</code> – počet sloupců;
</li><li><code>rows</code> – počet řádků.
</li></ul>
Návratová hodnota nechť je v případě úspěchu 0 a jinak -1
(například selže-li zápis na zadaný popisovač).
<!-- paragraph -->
</div>
<em><div class="par">Příklad:</em> Pro hodnoty <code>123, 456, 789, 1, 2, 3, 12, 3, 456</code> a
velikost tabulky 3 × 3 očekáváme, že na výstup bude vypsán
řetězec:
<!-- paragraph -->
</div>
<pre><code class="plain">"123, 456, 789\n"
"  1,   2,   3\n"
" 12,   3, 456\n"
</code></pre>
<div class="par">
Nápověda: jistě Vám přijde vhod procedura <code>dprintf</code> –
doporučujeme podívat se zejména co znamená znak <code>*</code> ve
formátovacím řetězci. Rovněž může být užitečná funkce <code>snprintf</code>
s omezením na nulovou délku.
<!-- paragraph -->
</div>
<pre><code class="cxx">int write_aligned( int fd, const int *values, int cols, int rows ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote24" href="#foothead24"><sup>24</sup></a><div class="par"> Existuje definice dle RFC 4180, nicméně tato se nezdá být  širší komunitou považována za závaznou. <!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Základy práce se soubory/[‹cut›]"><h3>1.p.5 [<code>cut</code>]</h3></a> <div class="par">Implementujte proceduru <code>cut</code>, která na popisovač <code>out</code> vypíše
sloupec zadaný parametrem <code>field</code> ze souboru <code>file</code> (sloupce
číslujeme od 1).<a class="anchor" id="foothead25" href="#footnote25"><sup>25</sup></a> Každý řádek na vstupu i výstupu bude zakončen
znakem <code>'\n'</code> a sloupce jsou na vstupu odděleny bajtem <code>delim</code>.
Soubor <code>file</code> hledejte ve složce určené popisovačem <code>dir</code>.
<!-- paragraph -->
</div>
<div class="par">Návratová hodnota: 0 – úspěch; -1 – systémová chyba.
<!-- paragraph -->
</div>
<pre><code class="cxx">int cut( int dir, const char* file, char delim, int field, int out ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote25" href="#foothead25"><sup>25</sup></a><div class="par"> Toto chování je podobné standardnímu příkazu <code>cut -d delim -f  field file</code>. <!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Základy práce se soubory/[‹cat›]"><h3>1.p.6 [<code>cat</code>]</h3></a> <div class="par">Naprogramujte proceduru <code>cat</code>, která obdrží tyto 3 parametry:
<!-- paragraph -->
</div>
<div class="par"><ul><li><code>dir_fd</code> – popisovač adresáře, ve kterém bude hledat všechny
níže zmíněné soubory,
</li><li><code>list</code> – jméno souboru se jmény souborů ke čtení,
</li><li><code>out_fd</code> – <em>výstupní</em> popisovač.
</li></ul>
Soubor <code>list</code> bude obsahovat na každém řádku jméno souboru.
Procedura <code>cat</code> zapíše obsahy všech těchto souborů (v zadaném
pořadí) do popisovače <code>out</code>.
<!-- paragraph -->
</div>
<div class="par">Stejně jako v předešlých příkladech za řádek považujeme
posloupnost znaků <em>zakončenou</em> <code>'\n'</code> (nikoliv tedy <code>"\r\n"</code> nebo
<code>'\r'</code>).
<!-- paragraph -->
</div>
<div class="par">Pro zjednodušení navíc zavedeme limit, kdy délka každého řádku
smí být nejvýše <code>name_max</code> bajtů (nepočítaje znak konce řádku).
<!-- paragraph -->
</div>
<!-- paragraph -->
<pre><code class="cxx">const int name_max = 256; 
</code></pre>
<div class="par">
Návratová hodnota 0 označuje úspěch. Pokud je některý ze řádků
souboru <code>list</code> delší než <code>name_max</code>, vraťte -2; nastane-li
systémová chyba, hodnotu -1.
<!-- paragraph -->
</div>
<div class="par">Nápověda: na popisovači k souboru <code>list</code> je možné používat volání
<code>lseek</code>. Jeho použitím si můžete usnadnit implementaci. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int cat( int dir_fd, const char *list, int out_fd ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Základy práce se soubory/Řešené úlohy"><h2>1.r Řešené úlohy</h2></a> <!-- paragraph -->
<a name="Základy práce se soubory/[‹wcount›]"><h3>1.r.1 [<code>wcount</code>]</h3></a> <div class="par">Za slovo budeme považovat posloupnost „nebílých“ znaků, po které
následují jeden či více „bílých“ znaků, nebo konec vstupu. Bílé
znaky uvažujeme ve smyslu standardní funkce <code>isspace</code> deklarované
v hlavičce &lt;ctype.h&gt;.
<!-- paragraph -->
</div>
<div class="par">Podprogram <code>count_words</code> zpracuje soubor o zadané cestě <code>file</code> a
výsledek vrátí skrze ukazatel <code>count</code>.
<!-- paragraph -->
</div>
<div class="par">Nastane-li systémová chyba, podprogram vrátí -1 (přitom hodnota
na adrese <code>count</code> není určena). V opačném případě vrátí 0. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int count_words( int dir_fd, const char *file, int *count ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Základy práce se soubory/[‹cgrep›]"><h3>1.r.2 [<code>cgrep</code>]</h3></a> <div class="par">Implementujte podprogram <code>cgrep</code>, která vypíše všechny řádky ze
vstupu <code>fd_in</code>, které obsahují znak <code>c</code>. Tyto řádky vypište na
popisovač <code>fd_out</code>. Pro tuto úlohy není stanoven žádný limit na
maximální délku řádku. Smíte ovšem předpokládat, že ve vstupním
souboru se lze posouvat voláním <code>lseek</code>.
<!-- paragraph -->
</div>
<div class="par">Návratová hodnota: 0 – úspěch; 1 – systémová chyba. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int cgrep( int fd_in, char c, int fd_out ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Základy práce se soubory/[‹flake›]"><h3>1.r.3 [<code>flake</code>]</h3></a> <div class="par">V této úloze budeme programovat funkci <code>path</code>, jejímž účelem bude
ověřit, zda zadaný soubor splňuje určitou vlastnost.
<!-- paragraph -->
</div>
<div class="par">Soubor musí obsahovat řádky nejvýše dané délky (ta je funkci
předána jako druhý parametr <code>len</code>). Každý řádek je zakončen
znakem '\n' a obsahuje pouze symboly ' ' a '*'. Na každém řádku
se musí vyskytovat právě jednou znak '*', který označuje pozici
pomyslného robota.
<!-- paragraph -->
</div>
<div class="par">Nevadí, pokud řádek obsahuje mezery mezi tímto znakem a koncem
řádku.
<!-- paragraph -->
</div>
<div class="par">Vaším úkolem je rozhodnout, zda mezi dvěma řádky vždy platí, že
robot změnil pozici nejvýše o jedna.
<!-- paragraph -->
</div>
<div class="par">Příklad: Uvažme následující řádky.
 1: "          *    \n"
 2: "           *\n"
 3: "         *\n"
Mezi řádky 1 a 2 se robot posunul o jedno pozici doprava, to je
v pořádku. Mezi řádky 2 a 3 se však robot posunul o dvě doleva,
tedy soubor celkově není validní.
<!-- paragraph -->
</div>
<div class="par">Návratová hodnota:
<ul><li>0 – čtení úspěšné a soubor je validní;
</li><li>1 – čtení úspěšné, ale robot se posunul o více pozic;
</li><li>2 – čtení úspěšné, ale soubor je špatného formátu;
</li><li>3 – čtení neúspěšné. 
</li></ul>
<pre><code class="cxx">int path( const char* file, int len ); 
</code></pre>

<!-- paragraph -->
</div>
<pre><code class="cxx">void main( void ) 
{
    return 0;
}
</code></pre>
<div class="par">

<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Základy práce se soubory/[‹bcount›]"><h3>1.r.4 [<code>bcount</code>]</h3></a> <div class="par">Podprogram <code>count_distinct</code> spočítá počet různých bajtů
v souboru. Tento počet v případě úspěchu vrátí, jinak vrátí
hodnotu -1. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int count_distinct( int dir_fd, const char *file ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Základy práce se soubory/[‹linked›]"><h3>1.r.5 [<code>linked</code>]</h3></a> <div class="par">Implementujte funkci <code>linked</code>, která přečte <em>první řádek</em>
zadaného souboru. Tento text se interpretuje jako název souboru,
kterým se má dále pokračovat. Nejprve ho vypíše (na popisovač
<code>out</code>) a potom soubor otevře a provede pro něj totéž.
<!-- paragraph -->
</div>
<div class="par">Tento proces se opakuje, dokud nenarazíme na prázdný soubor,
který zřetězenou sekvenci ukončí.
<!-- paragraph -->
</div>
<div class="par">Abychom nemuseli komplikovaně načítat neomezeně dlouhé názvy,
zavedeme zde limit pro délku názvu souboru 256 bajtů. Je-li první
řádek v některém vstupním souboru delší, funkce <code>linked</code> skončí
s návratovou hodnotou -2 (znak konce řádku se do tohoto limitu
nepočítá). Nastane-li systémová chyba, funkce nechť vrátí hodnotu
-1, jinak pak počet souborů, které otevřela. 
<!-- paragraph -->
</div>
<pre><code class="cxx">const int name_max = 256; 
</code></pre>
<div class="par">
<pre><code class="cxx">int linked( const char* file, int out ); 
</code></pre>

<!-- paragraph -->
</div>
<!-- paragraph -->
<!-- paragraph -->
<a name="Základy práce se soubory/[‹otp›]"><h3>1.r.6 [<code>otp</code>]</h3></a> <div class="par">V této úloze si naprogramujeme jednoduchou techniku
z kryptografie označovanou jako „one-time pad.“
<!-- paragraph -->
</div>
<div class="par">Funkci <code>otp</code> jsou zadány dva názvy souborů a výstupní popisovač.
Úkolem této funkce je na tento popisovač vypsat
<pre><code class="plain">‹obsah prvního XOR obsah druhého›.
</code></pre>

<em>Druhý</em> soubor zde považujeme za klíč a pro bezpečnost této
kryptografické techniky je nezbytné, aby jeho délka byla
<em>alespoň</em> taková jako je délka prvního.
<!-- paragraph -->
</div>
<div class="par">V případě, že tento požadavek není splněn, funkce nechť vrátí -2.
Jestliže nastane problém ve čtení některého souboru či problém
v zápisu na výstupní popisovač, vraťte -1. Pokud je vše úspěšné,
vraťte 0. 
<!-- paragraph -->
</div>
<pre><code class="cxx">int otp( const char* file, const char* key_file, int out ); 
</code></pre>
<div class="par">
<!-- paragraph -->
</div>
<!-- paragraph -->
<!-- paragraph -->
<!-- paragraph -->
<a name="Vzorová řešení"><h1>K Vzorová řešení</h1></a> <!-- paragraph -->
<a name="Vzorová řešení/Týden 1"><h2>K.1 Týden 1</h2></a> <!-- paragraph -->
<a name="Vzorová řešení/[‹wcount›]"><h3>K.1.r.1 [<code>wcount</code>]</h3></a> <pre><code class="cxx">int count_words( int dir_fd, const char *file, int *count ) 
{
    const int nbytes = 1024;
    char buffer[ nbytes ];
    int fd, bytes_read;
    int result = -1;
    bool in_word = false;
</code></pre>
<div class="par">
<pre><code class="cxx">    *count = 0; 
</code></pre>

<pre><code class="cxx">    if ( ( fd = openat( dir_fd, file, O_RDONLY ) ) == -1 ) 
        goto out;
</code></pre>

<pre><code class="cxx">    do { 
</code></pre>

<pre><code class="cxx">        if ( ( bytes_read = read( fd, buffer, nbytes ) ) == -1 ) 
            goto out;
</code></pre>

<pre><code class="cxx">        for ( int i = 0; i &lt; bytes_read; ++i ) 
            if ( in_word &amp;&amp; isspace( buffer[ i ] ) )
            {
                ++ *count;
                in_word = false;
            }
            else if ( !in_word &amp;&amp; !isspace( buffer[ i ] ) )
                in_word = true;
</code></pre>

<pre><code class="cxx">    } while ( bytes_read &gt; 0 ); 
</code></pre>

<pre><code class="cxx">    if ( in_word ) 
        ++ *count;
</code></pre>

<pre><code class="cxx">    result = 0; 
</code></pre>

<pre><code class="cxx">out: 
    if ( fd != -1 &amp;&amp; close( fd ) == -1 )
        warn( "closing %s", file );
    return result;
}
</code></pre>


<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Vzorová řešení/[‹cgrep›]"><h3>K.1.r.2 [<code>cgrep</code>]</h3></a> <pre><code class="cxx">int copy_span( int fd_in, int fd_out, int from, int to ) 
{
    const int nbytes = 1024;
    int bytes_total = 0, to_write, bytes_read;
    int orig_pos;
    char buffer[ nbytes ];
</code></pre>
<div class="par">
<pre><code class="cxx">    if ( ( orig_pos = lseek( fd_in, 0, SEEK_CUR ) ) == -1 ) 
        return -1;
</code></pre>

<pre><code class="cxx">    if ( lseek( fd_in, from, SEEK_SET ) == -1 ) 
        return -1;
</code></pre>

<pre><code class="cxx">    do { 
        if ( ( bytes_read = read( fd_in, buffer, nbytes ) ) == -1 )
            return -1;
</code></pre>

<pre><code class="cxx">        bytes_total += bytes_read; 
        to_write = bytes_read;
        int extra = bytes_total + from - to;
</code></pre>

<pre><code class="cxx">        if ( extra &gt; 0 ) 
            to_write -= extra;
</code></pre>

<pre><code class="cxx">        if ( write( fd_out, buffer, to_write ) == -1 ) 
            return -1;
    } while ( bytes_read &gt; 0 &amp;&amp; bytes_total &lt; to - from );
</code></pre>

<pre><code class="cxx">    if ( lseek( fd_in, orig_pos, SEEK_SET ) == -1 ) 
        return -1;
</code></pre>

<pre><code class="cxx">    return 0; 
}
</code></pre>

<pre><code class="cxx">int cgrep( int fd_in, char c, int fd_out ) 
{
    const int nbytes = 3;
    char buffer[ nbytes ];
    int bytes_read = 0, offset = 0, line_start = 0;
    bool matched = false;
</code></pre>

<pre><code class="cxx">    do { 
        if ( ( bytes_read = read( fd_in, buffer, nbytes ) ) == -1 )
            return -1;
</code></pre>

<pre><code class="cxx">        for ( int i = 0; i &lt; bytes_read; ++i, ++offset ) 
        {
            if ( buffer[ i ] == c )
                matched = true;
</code></pre>

<pre><code class="cxx">            if ( buffer[ i ] == '\n' ) 
            {
                if ( matched &amp;&amp;
                     copy_span( fd_in, fd_out, line_start,
                                offset + 1 ) == -1 )
                    return -1;
</code></pre>

<pre><code class="cxx">                line_start = offset + 1; 
                matched = false;
            }
        }
    } while ( bytes_read &gt; 0 );
</code></pre>

<pre><code class="cxx">    return 0; 
}
</code></pre>


<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Vzorová řešení/[‹bcount›]"><h3>K.1.r.4 [<code>bcount</code>]</h3></a> <pre><code class="cxx">int count_distinct( int dir_fd, const char *file ) 
{
    const int nbytes = 3;
    unsigned char buffer[ nbytes ];
    int counts[ 256 ] = { 0 };
    int fd = -1;
    int bytes_read;
    int result = -1, saved_errno;
</code></pre>
<div class="par">
<pre><code class="cxx">    if ( ( fd = openat( dir_fd, file, O_RDONLY ) ) == -1 ) 
        goto out;
</code></pre>

<pre><code class="cxx">    do { 
        if ( ( bytes_read = read( fd, buffer, nbytes ) ) == -1 )
            goto out;
</code></pre>

<pre><code class="cxx">        for ( int i = 0; i &lt; bytes_read; ++i ) 
            counts[ buffer[ i ] ] ++;
    } while ( bytes_read &gt; 0 );
</code></pre>

<pre><code class="cxx">    result = 0; 
</code></pre>

<pre><code class="cxx">    for ( int i = 0; i &lt; 256; ++i ) 
        if ( counts[ i ] )
            ++ result;
</code></pre>

<pre><code class="cxx">out: 
    saved_errno = errno;
</code></pre>

<pre><code class="cxx">    if ( fd != -1 &amp;&amp; close( fd ) == -1 ) 
        warn( "closing fd %d for %s", fd, file );
</code></pre>

<pre><code class="cxx">    errno = saved_errno; 
    return result;
}
</code></pre>

<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace"><h1>T Technické informace</h1></a> <div class="par">Tato kapitola obsahuje informace o technické realizaci předmětu,
a to zejména:
<!-- paragraph -->
</div>
<div class="par"><ul><li>jak se pracuje s kostrami úloh,
</li><li>jak sdílet obrazovku (terminál) ve cvičení,
</li><li>jak se odevzdávají úkoly,
</li><li>kde najdete výsledky testů a jak je přečtete,
</li><li>kde najdete hodnocení kvality kódu (učitelské recenze),
</li><li>jak získáte kód pro vzájemné recenze.
</li></ul>
<!-- paragraph -->
</div>
<a name="Technické informace/Informační systém"><h2>T.1 Informační systém</h2></a> <div class="par">Informační systém tvoří primární „rozhraní“ pro stahování studijních
materiálů, odevzdávání řešení, získání výsledků vyhodnocení a čtení
recenzí. Zároveň slouží jako hlavní komunikační kanál mezi studenty
a učiteli, prostřednictvím diskusního fóra.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Diskusní fórum"><h3>T.1.1 Diskusní fórum</h3></a> <div class="par">Máte-li dotazy k úlohám, organizaci, atp., využijte k jejich
položení prosím vždy přednostně diskusní fórum.<a class="anchor" id="foothead26" href="#footnote26"><sup>26</sup></a> Ke každé kapitole a
ke každému příkladu ze sady vytvoříme samostatné vlákno, kam patří
dotazy specifické pro tuto kapitolu nebo tento příklad. Pro řešení
obecných organizačních záležitostí a technických problémů jsou
podobně v diskusním fóru nachystaná vlákna.
<!-- paragraph -->
</div>
<div class="par">Než položíte libovolný dotaz, přečtěte si relevantní část dosavadní
diskuse – je možné, že na stejný problém už někdo narazil. Máte-li
ve fóru dotaz, na který se Vám nedostalo do druhého pracovního dne
reakce, připomeňte se prosím tím, že na tento svůj příspěvek
odpovíte.
<!-- paragraph -->
</div>
<div class="par">Máte-li dotaz k výsledku testu, nikdy tento výsledek nevkládejte do
příspěvku (podobně nikdy nevkládejte části řešení příkladu). Učitelé
mají přístup k obsahu Vašich poznámkových bloků, i k Vámi odevzdaným
souborům. Je-li to pro pochopení kontextu ostatními čtenáři potřeba,
odpovídající učitel chybějící informace doplní dle uvážení.
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote26" href="#foothead26"><sup>26</sup></a><div class="par"> Nebojte se do fóra napsat – když si s něčím nevíte rady a/nebo  nemůžete najít v materiálech, rádi Vám pomůžeme nebo Vás  nasměrujeme na místo, kde odpověď naleznete.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Technické informace/Stažení koster"><h3>T.1.2 Stažení koster</h3></a> <div class="par">Kostry naleznete ve <em>studijních materiálech</em> v ISu: <code>Student</code> →
<code>PB152</code> → <code>Studijní materály</code> → <code>Učební materiály</code>. Každá kapitola
má vlastní složku, pojmenovanou <code>00</code> (tento úvod a materiály
k nultému cvičení), <code>01</code> (první běžná kapitola), <code>02</code>, …, <code>12</code>.
Veškeré soubory stáhnete jednoduše tak, že na složku kliknete pravým
tlačítkem a vyberete možnost <code>Stáhnout jako ZIP</code>. Stažený soubor
rozbalte a můžete řešit.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Odevzdání řešení"><h3>T.1.3 Odevzdání řešení</h3></a> <div class="par">Vypracované příklady můžete odevzdat do <em>odevzdávárny</em> v ISu:
<code>Student</code> → <code>PB152</code> → <code>Odevzdávárny</code>. Pro přípravy používejte
odpovídající složky s názvy <code>01</code>, …, <code>12</code>. Pro příklady ze sad pak
<code>s1_a_csv</code>, atp. (složky začínající <code>s1</code> pro první, <code>s2</code> pro druhou
a <code>s3</code> pro třetí sadu).
<!-- paragraph -->
</div>
<div class="par">Soubor vložíte výběrem možnosti <code>Soubor – nahrát</code> (první ikonka na
liště nad seznamem souborů). Tímto způsobem můžete najednou nahrát
souborů několik (například všechny přípravy z dané kapitoly). Vždy
se ujistěte, že vkládáte správnou verzi souboru (a že nemáte
v textovém editoru neuložené změny). <em>Pozor!</em> Všechny vložené
soubory se musí jmenovat stejně jako v kostrách, jinak nebudou
rozeznány (IS při vkládání automaticky předřadí Vaše UČO – to je
v pořádku, název souboru po vložení do ISu <em>neměňte</em>) .
<!-- paragraph -->
</div>
<div class="par">O každém odevzdaném souboru (i nerozeznaném) se Vám v poznámkovém
bloku <code>log</code> objeví záznam. Tento záznam i výsledky testu syntaxe by
se měl objevit do několika minut od odevzdání (nemáte-li ani po 15
minutách výsledky, napište prosím do diskusního fóra).
<!-- paragraph -->
</div>
<div class="par">Archiv všech souborů, které jste úspěšně odevzdali, naleznete ve
složce <code>Private</code> ve studijních materiálech (<code>Student</code> → <code>PB152</code> →
<code>Studijní materiály</code> → <code>Private</code>).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Výsledky automatických testů"><h3>T.1.4 Výsledky automatických testů</h3></a> <div class="par">Automatickou zpětnou vazbu k odevzdaným úlohám budete dostávat
prostřednictvím tzv. <em>poznámkových bloků</em> v ISu. Ke každé
odevzdávárně existuje odpovídající poznámkový blok, ve kterém
naleznete aktuální výsledky testů. Pro přípravy bude blok vypadat
přibližně takto:
<!-- paragraph -->
</div>
<pre><code class="plain">testing verity of submission from 2022-09-17 22:43 CEST
subtest p1_foo passed    [0.5]
subtest p2_bar failed
subtest p3_baz failed
subtest p4_quux passed   [0.5]
subtest p5_wibble passed [0.5]
subtest p6_xyzzy failed
   {bližší popis chyby}
verity test failed

testing syntax of submission from 2022-09-17 22:43 CEST
subtest p1_foo passed
subtest p2_bar failed
  {bližší popis chyby}
subtest p3_baz failed
  {bližší popis chyby}
subtest p4_quux passed
subtest p5_wibble passed
subtest p6_xyzzy passed
syntax test failed

testing sanity of submission from 2022-09-17 22:43 CEST
subtest p1_foo passed    [  1]
subtest p2_bar failed
subtest p3_baz failed
subtest p4_quux passed   [  1]
subtest p5_wibble passed [  1]
subtest p6_xyzzy passed  [  1]
sanity test failed

best submission: 2022-09-17 22:43 CEST worth *5.5 point(s)
</code></pre>
<div class="par">
Jednak si všimněte, že každý odstavec má <em>vlastní časové razítko</em>,
které určuje, ke kterému odevzdání daný výstup patří. Tato časová
razítka nemusí být stejná. V hranatých závorkách jsou uvedeny dílčí
body, za hvězdičkou na posledním řádku pak celkový bodový zisk za
tuto kapitolu.
<!-- paragraph -->
</div>
<div class="par">Také si všimněte, že <code>best submission</code> se vztahuje na jedno
konkrétní odevzdání jako celek: v situaci, kdy odstavec „verity“ a
odstavec „sanity“ nemají stejné časové razítko, <em>nemusí</em> být celkový
bodový zisk součtem všech dílčích bodů.  O konečném zisku rozhoduje
vždy poslední odevzdání před příslušným termínem (opět jako jeden
celek).<a class="anchor" id="foothead27" href="#footnote27"><sup>27</sup></a>
<!-- paragraph -->
</div>
<div class="par">Výstup pro příklady ze sad je podobný, uvažme například:
<!-- paragraph -->
</div>
<pre><code class="plain">testing verity of submission from 2022-10-11 21:14 CEST
subtest foo-small passed
subtest foo-large passed
verity test passed          [ 10]

testing syntax of submission from 2022-10-14 23:54 CEST
subtest build passed
syntax test passed

testing sanity of submission from 2022-10-14 23:54 CEST
subtest foo passed
sanity test passed

best submission: 2022-10-11 21:14 CEST worth *10 point(s)
</code></pre>
<div class="par">
Opět si všimněte, že časová razítka se mohou lišit (a v případě
příkladů ze sady bude k této situaci docházet poměrně často, vždy
tedy nejprve ověřte, ke kterému odevzdání se který odstavec vztahuje
a pak až jej dále interpretujte).
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote27" href="#foothead27"><sup>27</sup></a><div class="par"> Můžete si tak odevzdáním nefunkčních řešení na poslední chvíli  snížit výsledný bodový zisk. Uvažte situaci, kdy máte v pátek 4  body za sanity příkladů p1, p2, p3, p6 a 1 bod za verity p1, p2.  V sobotu odevzdáte řešení, kde p1 neprochází sanity testem, ale p4  ano a navíc projdou verity testy příklady p4 a p6. Váš výsledný  zisk bude 5.5 bodu. Tento mechanismus Vám nikdy nesníží výsledný  bodový zisk pod již jednou dosaženou hranici „best submission“.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Technické informace/Recenze"><h3>T.1.5 Recenze </h3></a> <div class="par">Vám adresované recenze, podobně jako archiv odevzdaných souborů,
naleznete ve složce <code>Private</code> ve studijních materiálech (<code>Student</code> →
<code>PB152</code> → <code>Studijní materiály</code> → <code>Private</code>). Shrnutí bodového zisku
za tyto recenze pak naleznete v poznámkovém bloku <code>reviews</code>.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Další poznámkové bloky"><h3>T.1.6 Další poznámkové bloky</h3></a> <div class="par">Blok <code>corr</code> obsahuje záznamy o manuálních bodových korekcích (např.
v situaci, kdy byl Váš bodový zisk ovlivněn chybou v testech).
Podobně se zde objeví záznamy o penalizaci za opisování.
<!-- paragraph -->
</div>
<div class="par">Blok <code>log</code> obsahuje záznam o všech odevzdaných souborech, včetně
těch, které nebyly rozeznány. Nedostanete-li po odevzdání příkladu
výsledek testů, ověřte si v tomto poznámkovém bloku, že soubor byl
správně rozeznán.
<!-- paragraph -->
</div>
<div class="par">Blok <code>misc</code> obsahuje záznamy o Vaší aktivitě ve cvičení (netýká se
bodů za vzájemné recenze ani vnitrosemestrální testy). Nemáte-li
před koncem cvičení, ve kterém jste řešili příklad u tabule, záznam
v tomto bloku, připomeňte se svému cvičícímu.
<!-- paragraph -->
</div>
<div class="par">Konečně blok <code>sum</code> obsahuje souhrn bodů, které jste dosud získali, a
které ještě získat můžete. Dostanete-li se do situace, kdy Vám ani
zisk všech zbývajících bodů nebude stačit pro splnění podmínek
předmětu, tento blok Vás o tom bude informovat. Tento blok má navíc
přístupnou statistiku bodů – můžete tak srovnat svůj dosavadní
bodový zisk se svými spolužáky.
<!-- paragraph -->
</div>
<div class="par">Je-li blok <code>sum</code> v rozporu s pravidly uvedenými v tomto dokumentu,
přednost mají pravidla zde uvedená. Podobně mají v případě
nesrovnalosti přednost dílčí poznámkové bloky. Dojde-li k takovéto
neshodě, informujte nás o tom prosím v diskusním fóru. Případná
známka uvedená v poznámkovém bloku <code>sum</code> je podobně pouze
informativní – rozhoduje vždy známka zapsaná v hodnocení předmětu.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Studentský server ‹aisa›"><h2>T.2 Studentský server <code>aisa</code></h2></a> <div class="par">Použití serveru <code>aisa</code> pro odevzdávání příkladů je zcela volitelné a
vše potřebné můžete vždy udělat i prostřednictvím ISu. Nevíte-li si
s něčím z níže uvedeného rady, použijte IS.
<!-- paragraph -->
</div>
<div class="par">Na server <code>aisa</code> se přihlásíte programem <code>ssh</code>, který je k dispozici
v prakticky každém moderním operačním systému (v OS Windows skrze
WSL<a class="anchor" id="foothead28" href="#footnote28"><sup>28</sup></a> – Windows Subsystem for Linux). Konkrétní příkaz (za <code>xlogin</code>
doplňte ten svůj):
<!-- paragraph -->
</div>
<pre><code class="plain">$ ssh xlogin@aisa.fi.muni.cz
</code></pre>
<div class="par">
Program se zeptá na heslo: použijte to fakultní (to stejné, které
používáte k přihlášení na ostatní fakultní počítače, nebo např. ve
<code>fadmin</code>-u nebo fakultním <code>gitlab</code>-u).
<!-- paragraph -->
</div>
<!-- paragraph -->
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote28" href="#foothead28"><sup>28</sup></a><div class="par"> Jako alternativu, nechcete-li z nějakého důvodu WSL instalovat,  lze použít program <code>putty</code>.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Technické informace/Pracovní stanice"><h3>T.2.1 Pracovní stanice</h3></a> <div class="par">Veškeré instrukce, které zde uvádíme pro použití na stroji <code>aisa</code>
platí beze změn také na libovolné školní UNIX-ové pracovní stanici
(tzn. z fakultních počítačů není potřeba se hlásit na stroj <code>aisa</code>,
navíc mají sdílený domovský adresář, takže svoje soubory z tohoto
serveru přímo vidíte, jako by byly uloženy na pracovní stanici).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Stažení koster"><h3>T.2.2 Stažení koster</h3></a> <div class="par">Aktuální zdrojový balík stáhnete příkazem:
<!-- paragraph -->
</div>
<pre><code class="plain">$ pb152 update
</code></pre>
<div class="par">
Stažené soubory pak naleznete ve složce <code>~/pb152</code>. Je bezpečné tento
příkaz použít i v případě, že ve své kopii již máte rozpracovaná
řešení – systém je při aktualizaci nepřepisuje. Došlo-li ke změně
kostry u příkladu, který máte lokálně modifikovaný, aktualizovanou
kostru naleznete v souboru s dodatečnou příponou <code>.pristine</code>, např.
<code>01/e2_concat.cpp.pristine</code>. V takovém případě si můžete obě verze
srovnat příkazem <code>diff</code>:
<!-- paragraph -->
</div>
<pre><code class="plain">$ diff -u e2_concat.cpp e2_concat.cpp.pristine
</code></pre>
<div class="par">
Případné relevantní změny si pak již lehce přenesete do svého
řešení.
<!-- paragraph -->
</div>
<div class="par">Krom samotného zdrojového balíku Vám příkaz <code>pb152 update</code> stáhne i
veškeré recenze (jak od učitelů, tak od spolužáků). To, že máte
k dispozici nové recenze, uvidíte ve výpisu. Recenze najdete ve
složce <code>~/pb152/reviews</code>.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Odevzdání řešení"><h3>T.2.3 Odevzdání řešení</h3></a> <div class="par">Odevzdat vypracované (nebo i rozpracované) řešení můžete ze složky
s relevantními soubory takto:
<!-- paragraph -->
</div>
<pre><code class="plain">$ cd ~/pb152/01
$ pb152 submit
</code></pre>
<div class="par">
Přidáte-li přepínač <code>--wait</code>, příkaz vyčká na vyhodnocení testů fáze
„syntax“ a jakmile je výsledek k dispozici, vypíše obsah příslušného
poznámkového bloku. Chcete-li si ověřit co a kdy jste odevzdali,
můžete použít příkaz
<!-- paragraph -->
</div>
<pre><code class="plain">$ pb152 status
</code></pre>
<div class="par">
nebo se podívat do informačního systému (blíže popsáno v sekci T.1).
<!-- paragraph -->
</div>
<em><div class="par">Pozor!</em> Odevzdáváte-li stejnou sadu příprav jak v ISu tak
prostřednictvím příkazu <code>pb152</code>, ujistěte se, že odevzdáváte vždy
všechny příklady.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Sdílení terminálu"><h3>T.2.4 Sdílení terminálu</h3></a> <div class="par">Řešíte-li příklad typu <code>r</code> ve cvičení, bude se Vám pravděpodobně
hodit režim sdílení terminálu s cvičícím (který tak bude moct
promítat Váš zdrojový kód na plátno, případně do něj jednoduše
zasáhnout).
<!-- paragraph -->
</div>
<div class="par">Protože se sdílí pouze terminál, budete se muset spokojit
s negrafickým textovým editorem (doporučujeme použít <code>micro</code>,
případně <code>vim</code> umíte-li ho ovládat). Spojení navážete příkazem:
<!-- paragraph -->
</div>
<pre><code class="plain">$ pb152 beamer
</code></pre>
<div class="par">
Protože příkaz vytvoří nové sezení, nezapomeňte se přesunout do
správné složky příkazem <code>cd ~/pb152/NN</code>.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Recenze"><h3>T.2.5 Recenze </h3></a> <div class="par">Příkaz <code>pb152 update</code> krom zdrojového balíku stahuje také:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>zdrojové kódy, které máte možnost recenzovat, a to do složky
<code>~/pb152/to_review</code>,
</li><li>recenze, které jste na svůj kód obdrželi (jak od spolužáků, tak
od vyučujících), a to do stávajících složek zdrojového balíku
(tzn. recenze na příklady z první kapitoly se Vám objeví ve
složce <code>~/pb152/01</code> – že se jedná o recenzi poznáte podle jména
souboru, který bude začínat uživatelským jménem autora recenze,
např. <code>xrockai.00123.p1_nhamming.cpp</code>).
</li></ol>
Chcete-li vypracované recenze odeslat:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>přesuňte se do složky <code>~/pb152/to_review</code> a
</li><li>zadejte příkaz <code>pb152 submit</code>, případně doplněný o seznam
souborů, které hodláte odeslat (jinak se odešlou všechny, které
obsahují jakýkoliv přidaný komentář).
</li></ol>
<!-- paragraph -->
</div>
<a name="Technické informace/Kostry úloh"><h2>T.3 Kostry úloh</h2></a> <div class="par">Pracujete-li na studentském serveru <code>aisa</code>, můžete pro překlad
jednotlivých příkladů použít přiložený soubor <code>makefile</code>, a to
zadáním příkazu
<!-- paragraph -->
</div>
<pre><code class="plain">$ make příklad
</code></pre>
<div class="par">
kde <code>příklad</code> je název souboru bez přípony (např. tedy <code>make
e1_factorial</code>). Tento příkaz postupně:
<!-- paragraph -->
</div>
<div class="par"><ol start="1"><li>přeloží Vaše řešení překladačem <code>gcc</code>,
</li><li>spustí přiložené testy,
</li><li>spustí kontrolu nástrojem <code>valgrind</code>.
</li></ol>
Selže-li některý krok, další už se provádět nebude. Povede-li se
překlad v prvním kroku, v pracovním adresáři naleznete spustitelný
soubor s názvem <code>příklad</code>, se kterým můžete dále pracovat (např. ho
ladit/krokovat nástrojem <code>gdb</code>).
<!-- paragraph -->
</div>
<div class="par">Existující přeložené soubory můžete smazat příkazem <code>make clean</code>
(vynutíte tak jejich opětovný překlad a spuštění všech kontrol).
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Textový editor"><h3>T.3.1 Textový editor</h3></a> <div class="par">Na stroji <code>aisa</code> je k dispozici jednoduchý editor <code>micro</code>, který má
podobné ovládání jako klasické textové editory, které pracují
v grafickém režimu, a který má slušnou podporu pro práci se
zdrojovým kódem. Doporučujeme zejména méně pokročilým. Další
možností jsou samozřejmě pokročilé editory <code>vim</code> a <code>emacs</code>.
<!-- paragraph -->
</div>
<div class="par">Mimo lokálně dostupné editory si můžete ve svém oblíbeném editoru,
který máte nainstalovaný u sebe, nastavit režim vzdálené editace
(použitím protokolu <code>ssh</code>). Minimálně ve VS Code je takový režim
k dispozici a je uspokojivě funkční.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Technické informace/Vlastní prostředí"><h3>T.3.2 Vlastní prostředí</h3></a> <div class="par">Každý příklad je zcela obsažen v jednom standardním zdrojovém
souboru, proto je jejich překlad velmi jednoduchý. Pravděpodobně
každé IDE zvládne s příklady bez problémů pracovat (spouštět, ladit,
atp.), musí ale běžet na systému typu POSIX (splňují všechny OS krom
Windows – zde ale můžete využít WSL a případně jeho
<em><a href="https://code.visualstudio.com/docs/remote/wsl">integraci do VS Code</a></em>).
<!-- paragraph -->
</div>
<div class="par">Krom IDE můžete také použít dodaný soubor <code>makefile</code>, pouze si
v nadřazené složce (tzn. <em>vedle</em> složek <code>01</code>, <code>02</code>, atd.) vytvořte
soubor <code>local.mk</code>, ve kterém nastavíte, jak se na Vašem systému
spouští potřebné příkazy. Implicitní nastavení je toto, a funguje-li
Vám, není potřeba soubor <code>local.mk</code> vůbec vytvářet:
<!-- paragraph -->
</div>
<pre><code class="plain">CC = cc
VALGRIND = valgrind
</code></pre>
<div class="par">
Můžete samozřejmě příklady překládat a kontrolovat i ručně.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Doporučení k zápisu kódu"><h1>Z Doporučení k zápisu kódu</h1></a> <div class="par">Tato sekce rozvádí obecné principy zápisu kódu s důrazem na
čitelnost a korektnost. Samozřejmě žádná sada pravidel nemůže
zaručit, že napíšete dobrý (korektní a čitelný) program, o nic více,
než může zaručit, že napíšete dobrou povídku nebo namalujete dobrý
obraz. Přesto ve všech těchto případech pravidla existují a jejich
dodržování má obvykle na výsledek pozitivní dopad.
<!-- paragraph -->
</div>
<div class="par">Každé pravidlo má samozřejmě nějaké výjimky. Tyto jsou ale výjimkami
proto, že nastávají <em>výjimečně</em>. Některá pravidla připouští výjimky
častěji než jiná: 
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Doporučení k zápisu kódu/Dekompozice"><h3>Z.0.1 Dekompozice</h3></a> <div class="par">Vůbec nejdůležitější úlohou programátora je rozdělit problém tak,
aby byl schopen každou část správně vyřešit a dílčí výsledky pak
poskládat do korektního celku.
<!-- paragraph -->
</div>
<div class="par"><ol start="1" class="alpha"><li>Kód musí být rozdělen do ucelených jednotek (kde jednotkou
rozumíme funkci, typ, modul, atd.) přiměřené velikosti, které
lze studovat a používat nezávisle na sobě.
</li><li>Jednotky musí být od sebe odděleny jasným <em>rozhraním</em>, které by
mělo být jednodušší a uchopitelnější, než kdybychom použití
jednotky nahradili její definicí.
</li><li>Každá jednotka by měla mít <em>jeden</em> dobře definovaný účel, který
je zachycený především v jejím pojmenování a případně rozvedený
v komentáři.
</li><li>Máte-li problém jednotku dobře pojmenovat, může to být známka
toho, že dělá příliš mnoho věcí.
</li><li>Jednotka by měla realizovat vhodnou <em>abstrakci</em>, tzn. měla by
být <em>obecná</em> – zkuste si představit, že dostanete k řešení
nějaký jiný (ale dostatečně příbuzný) problém: bude Vám tato
konkrétní jednotka k něčemu dobrá, aniž byste ji museli
(výrazně) upravovat?
</li><li>Má-li jednotka parametr, který fakticky identifikuje místo ve
kterém ji používáte (bez ohledu na to, je-li to z jeho názvu
patrné), je to často známka špatně zvolené abstrakce. Máte-li
parametr, který by bylo lze pojmenovat <code>called_from_bar</code>, je to
jasná známka tohoto problému.
</li><li>Daný podproblém by měl být vyřešen v programu pouze jednou –
nedaří-li se Vám sjednotit různé varianty stejného nebo velmi
podobného kódu (aniž byste se uchýlili k taktice z bodu d), může
to být známka nesprávně zvolené dekompozice. Zkuste se zamyslet,
není-li možné problém rozložit na podproblémy jinak.
</li></ol>
<!-- paragraph -->
</div>
<a name="Doporučení k zápisu kódu/Jména"><h3>Z.0.2 Jména</h3></a> <div class="par">Dobře zvolená jména velmi ulehčují čtení kódu, ale jsou i dobrým
vodítkem při dekompozici a výstavbě abstrakcí.
<!-- paragraph -->
</div>
<div class="par"><ol start="1" class="alpha"><li>Všechny entity ve zdrojovém kódu nesou <em>anglická</em> jména.
Angličtina je univerzální jazyk programátorů.
</li><li>Jméno musí být <em>výstižné</em> a <em>popisné</em>: v místě použití je
obvykle jméno náš hlavní (a často jediný) <em>zdroj informací</em>
o jmenované entitě. Nutnost hledat deklaraci nebo definici
(protože ze jména není jasné, co volaná funkce dělá, nebo jaký
má použitá proměnná význam) čtenáře nesmírně zdržuje.<a class="anchor" id="foothead29" href="#footnote29"><sup>29</sup></a>
</li><li>Jména <em>lokálního</em> významu mohou být méně informativní: je mnohem
větší šance, že význam jmenované entity si pamatujeme, protože
byla definována před chvílí (např. lokální proměnná v krátké
funkci).
</li><li>Obecněji, informační obsah jména by měl být přímo úměrný jeho
rozsahu platnosti a nepřímo úměrný frekvenci použití: globální
jméno musí být informativní, protože jeho definice je „daleko“
(takže si ji už nepamatujeme) a zároveň se nepoužívá příliš
často (takže si nepamatujeme ani to, co jsme se dozvěděli, když
jsme ho potkali naposled).
</li><li>Jméno parametru má dvojí funkci: krom toho, že ho používáme
v těle funkce (kde se z pohledu pojmenování chová podobně jako
lokální proměnná), slouží jako dokumentace funkce jako celku.
Pro parametry volíme popisnější jména, než by zaručovalo jejich
použití ve funkci samotné – mají totiž dodatečný globální
význam.
</li><li>Některé entity mají ustálené názvy – je rozumné se jich držet,
protože čtenář automaticky rozumí jejich významu, i přes
obvyklou stručnost. Zároveň je potřeba se vyvarovat použití
takovýchto ustálených jmen pro nesouvisející entity.  Typickým
příkladem jsou iterační proměnné <code>i</code> a <code>j</code>.
</li><li>Jména s velkým rozsahem platnosti by měla být také
<em>zapamatovatelná</em>. Je vždy lepší si přímo vzpomenout na jméno
funkce, kterou právě potřebuji, než ho vyhledávat (podobně jako
je lepší znát slovo, než ho jít hledat ve slovníku).
</li><li>Použitý slovní druh by měl odpovídat druhu entity, kterou
pojmenovává. Proměnné a typy pojmenováváme přednostně
podstatnými jmény, funkce přednostně slovesy.
</li><li>Rodiny příbuzných nebo souvisejících entit pojmenováváme podle
společného schématu (<code>table_name</code>, <code>table_size</code>, <code>table_items</code> –
nikoliv např. <code>items_in_table</code>; <code>list_parser</code>, <code>string_parser</code>,
<code>set_parser</code>; <code>find_min</code>, <code>find_max</code>, <code>erase_max</code> – nikoliv
např. <code>erase_maximum</code> nebo <code>erase_greatest</code> nebo <code>max_remove</code>).
</li><li>Jména by měla brát do úvahy kontext, ve kterém jsou platná.
Neopakujte typ proměnné v jejím názvu (<code>cars</code>, nikoliv
<code>list_of_cars</code> ani <code>set_of_cars</code>) nemá-li tento typ speciální
význam. Podobně jméno nadřazeného typu nepatří do jmen jeho
metod (třída <code>list</code> by měla mít metodu <code>length</code>, nikoliv
<code>list_length</code>).
</li><li>Dávejte si pozor na překlepy a pravopisné chyby. Zbytečně
znesnadňují pochopení a (zejména v kombinaci s našeptávačem)
lehce vedou na skutečné chyby způsobené záměnou podobných ale
jinak napsaných jmen. Navíc kód s překlepy v názvech působí
značně neprofesionálně.
</li></ol>
<!-- paragraph -->
</div>
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote29" href="#foothead29"><sup>29</sup></a><div class="par"> Nejde zde pouze o samotný fakt, že je potřeba něco vyhledat. Mohlo  by se zdát, že tento problém řeší IDE, které nás umí „poslat“ na  příslušnou definici samo. Hlavní zdržení ve skutečnosti spočívá  v tom, že musíme přerušit čtení předchozího celku. Na rozdíl od  počítače je pro člověka „zanořování“ a zejména pak „vynořování“ na  pomyslném zásobníku docela drahou operací.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Doporučení k zápisu kódu/Stav a data"><h3>Z.0.3 Stav a data</h3></a> <div class="par">Udržet si přehled o tom, co se v programu děje, jaké jsou vztahy
mezi různými stavovými proměnnými, co může a co nemůže nastat, je
jedna z nejtěžších částí programování.
<!-- paragraph -->
</div>
<div class="par">TBD: Vstupní podmínky, invarianty, …
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Doporučení k zápisu kódu/Řízení toku"><h3>Z.0.4 Řízení toku</h3></a> <div class="par">Přehledný, logický a co nejvíce lineární sled kroků nám ulehčuje
pochopení algoritmu. Časté, komplikované větvení je naopak těžké
sledovat a odvádí pozornost od pochopení důležitých myšlenek.
<!-- paragraph -->
</div>
<div class="par">TBD.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Doporučení k zápisu kódu/Volba algoritmů a datových struktur"><h3>Z.0.5 Volba algoritmů a datových struktur</h3></a> <div class="par">TBD.
<!-- paragraph -->
</div>
<!-- paragraph -->
<a name="Doporučení k zápisu kódu/Komentáře"><h3>Z.0.6 Komentáře</h3></a> <div class="par">Nejde-li myšlenku předat jinak, vysvětlíme ji doprovodným
komentářem. Čím těžší myšlenka, tím větší je potřeba komentovat.
<!-- paragraph -->
</div>
<div class="par"><ol start="1" class="alpha"><li>Podobně jako jména entit, komentáře které jsou součástí kódu
píšeme anglicky.<a class="anchor" id="foothead30" href="#footnote30"><sup>30</sup></a>
</li><li>Případný komentář jednotky kódu by měl vysvětlit především „co“
a „proč“ (tzn. jaký plní tato jednotka účel a za jakých
okolností ji lze použít).
</li><li>Komentář by také neměl zbytečně duplikovat informace, které jsou
k nalezení v hlavičce nebo jiné „nekomentářové“ části kódu –
jestli máte například potřebu komentovat parametr funkce,
zvažte, jestli by nešlo tento parametr lépe pojmenovat nebo
otypovat.
</li><li>Komentář by <em>neměl</em> zbytečně duplikovat samotný spustitelný kód
(tzn. neměl by se zdlouhavě zabývat tím „jak“ jednotka vnitřně
pracuje). Zejména jsou nevhodné komentáře typu „zvýšíme
proměnnou i o jedna“ – komentář lze použít k vysvětlení <em>proč</em>
je tato operace potřebná – co daná operace dělá si může kažďý
přečíst v samotném kódu.
</li></ol>
<!-- paragraph -->
</div>
<div class="par footnotes"><div class="footnote"><a class="anchor" id="footnote30" href="#foothead30"><sup>30</sup></a><div class="par"> Tato sbírka samotná představuje ústupek z tohoto pravidla: smyslem  našich komentářů je naučit Vás poměrně těžké a často nové  koncepty, a její cirkulace je omezená. Zkušenost z dřívějších let  ukazuje, že pro studenty je anglický výklad značnou bariérou  pochopení. Přesto se snažte vlastní kód komentovat anglicky –  výjimku lze udělat pouze pro rozsáhlejší komentáře, které byste  jinak nedokázali srozumitelně formulovat. V praxi je angličtina  zcela běžně bezpodmínečně vyžadovaná.<!-- paragraph -->
</div>
</div></div><!-- paragraph -->
<a name="Doporučení k zápisu kódu/Formální úprava"><h3>Z.0.7 Formální úprava</h3></a> <div class="par">TBD.
</div></body></html>